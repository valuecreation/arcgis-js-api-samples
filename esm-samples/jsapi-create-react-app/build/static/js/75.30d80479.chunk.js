(this["webpackJsonpjsapi-create-react-app"]=this["webpackJsonpjsapi-create-react-app"]||[]).push([[75],{1161:function(t,e,n){"use strict";n.r(e),n.d(e,"meshFeatureSetFromJSON",(function(){return At}));var r=n(124),o=n(2),i=n(50),a=n(0),c=n(11),s=n(159),l=n(7),u=n(206),b=n(12),f=n(1),p=(n(8),n(9),n(4)),j=n(5),h=n(146),g=n(41),O=n(144),m=n(777),d=n(594),y=n(802),x=n(595),v=n(396),w=n(36),A=n(757),R=n(776);const F=l.a.getLogger("esri.geometry.support.meshUtils.centerAt");function M(t,e,n){var r;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const i=null!=(r=null==n?void 0:n.origin)?r:t.origin;Object(o.j)(t.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==t.transform.geographic&&F.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e,n){const r=e.x-n.x,o=e.y-n.y,i=e.hasZ&&n.hasZ?e.z-n.z:0,a=t.origin;t.origin=[a[0]+r,a[1]+o,a[2]+i]}(t.transform,e,i)):Object(A.a)(t.spatialReference,n)?function(t,e,n){const r=Object(R.d)(t.vertexAttributes,n,{geographic:!0}),{position:o,normal:i,tangent:a}=Object(R.a)(r,e,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=i,t.vertexAttributes.tangent=a,t.vertexAttributesChanged()}(t,e,i):function(t,e,n){const r=P,o=z;if(Object(w.u)(e,o,t.spatialReference)){if(!Object(w.u)(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,F.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function(t,e,n){if(t)for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=e[o]-n[o]})(t.vertexAttributes.position,o,r),t.vertexAttributesChanged()}else F.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,e,i)}const z=Object(j.e)(),P=Object(j.e)();var T=n(25);function E(t){const e=Object(T.G)(t.url);return n=>{var r;const o=Object(T.C)(n,e,e),i=o?o.replace(/^ *\.\//,""):null;return null!=(r=t.files.get(i))?r:n}}async function L(t,e){return t instanceof Blob?C.fromBlob(t):"string"==typeof t?new C(t):Array.isArray(t)?async function(t,e){const n=new Map;let r=null;const i=await Object(b.l)(t.map((async t=>({name:t.name,source:await L(t instanceof Blob?t:t.source,e)})))),a=[];for(const o of i)o&&(Object(b.o)(e)?o.source.dispose():a.push(o));Object(b.x)(e);for(const{name:c,source:s}of a)(Object(o.i)(r)||/\.(gltf|glb)/i.test(c))&&(r=s.url),n.set(c,s.url),s.files&&s.files.forEach(((t,e)=>n.set(e,t)));if(Object(o.i)(r))throw new c.a("mesh-load-external:missing-files","Missing files to load external mesh source");return new C(r,(()=>a.forEach((({source:t})=>t.dispose()))),n)}(t,e):async function(t,e){const{default:r}=await Object(b.A)(Promise.resolve().then(n.bind(null,84)),e),o="string"==typeof t.multipart[0]?await Promise.all(t.multipart.map((async t=>(await r(t,{responseType:"array-buffer"})).data))):t.multipart;return C.fromBlob(new Blob(o))}(t,e)}class C{constructor(t,e=(()=>{}),n=new Map){this.url=t,this.dispose=e,this.files=n}static fromBlob(t){const e=URL.createObjectURL(t);return new C(e,(()=>URL.revokeObjectURL(e)))}}var S=n(52),I=n(83),k=n(20),N=n(3),$=n(53),U=n(380);const B=l.a.getLogger("esri.geometry.support.meshUtils.offset");function G(t,e,n){t.vertexAttributes&&t.vertexAttributes.position&&(Object(o.j)(t.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==t.transform.geographic&&B.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e){const n=t.origin;t.origin=Object(N.h)(Object(j.e)(),n,e)}(t.transform,e)):Object(A.a)(t.spatialReference,n)?function(t,e){const n=t.spatialReference,r=t.vertexAttributes.position,i=t.vertexAttributes.normal,a=t.vertexAttributes.tangent,c=new Float64Array(r.length),s=Object(o.j)(i)?new Float32Array(i.length):null,l=Object(o.j)(a)?new Float32Array(a.length):null,u=t.extent.center,b=Y;Object(w.d)(n,[u.x,u.y,u.z],_,Object($.g)(n)),Object(S.f)(D,_),Object(N.z)(b,e,D),Object(U.f)(r,n,c),Object(o.j)(i)&&Object(U.c)(i,r,c,n,s),Object(o.j)(a)&&Object(U.e)(a,r,c,n,l),Z(c,b),Object(U.a)(c,r,n),Object(o.j)(i)&&Object(U.b)(s,r,c,n,i),Object(o.j)(a)&&Object(U.d)(l,r,c,n,a),t.vertexAttributesChanged()}(t,e):function(t,e){Z(t.vertexAttributes.position,e),t.vertexAttributesChanged()}(t,e))}function Z(t,e){if(t)for(let n=0;n<t.length;n+=3)for(let r=0;r<3;r++)t[n+r]+=e[r]}const Y=Object(j.e)(),_=Object(k.d)(),D=Object(I.b)();const J={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function q(t,e,n){(function(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5})(t),function(t,e){if(null==e)return;const n="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];H[0]=n[0],H[4]=n[1],H[8]=n[2];for(let r=0;r<t.position.length;r+=3){for(let e=0;e<3;e++)V[e]=t.position[r+e];Object(N.z)(V,V,H);for(let e=0;e<3;e++)t.position[r+e]=V[e]}if(n[0]!==n[1]||n[1]!==n[2]){H[0]=1/n[0],H[4]=1/n[1],H[8]=1/n[2];for(let e=0;e<t.normal.length;e+=3){for(let n=0;n<3;n++)V[n]=t.normal[e+n];Object(N.z)(V,V,H),Object(N.t)(V,V);for(let n=0;n<3;n++)t.normal[e+n]=V[n]}}}(t,n&&n.size);const{vertexAttributes:r,transform:o}=Object(R.c)(t,e,n);return{vertexAttributes:new x.c({...r,uv:t.uv}),transform:o,components:[new d.a({faces:t.faces,material:n&&n.material||null})],spatialReference:e.spatialReference}}const W={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},X={south:0,east:1,north:2,west:3,up:4,down:5},V=Object(j.e)(),H=Object(I.b)();var K=n(16);const Q=l.a.getLogger("esri.geometry.support.meshUtils.rotate");function tt(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const r=t.spatialReference;if(Object(o.j)(t.transform)){var i;null!=(null==n?void 0:n.geographic)&&n.geographic!==t.transform.geographic&&Q.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=null!=(i=null==n?void 0:n.origin)?i:t.transform.getOriginPoint(r);!function(t,e,n){const r=Object(N.y)(nt,n.x,n.y,n.z),o=Object(N.l)(nt,r,t.origin);t.applyLocalInverse(o,rt),t.rotation=Object(m.c)(t.rotation,e,Object(m.d)()),t.applyLocalInverse(o,o),Object(N.l)(o,o,rt),t.translation=Object(N.h)(Object(j.e)(),t.translation,o)}(t.transform,e,o)}else{var a;const r=null!=(a=null==n?void 0:n.origin)?a:t.origin;Object(A.a)(t.spatialReference,n)?function(t,e,n){const r=t.spatialReference,i=Object($.g)(r),a=ct;Object(w.u)(n,a,i)||Object(w.u)(t.origin,a,i);const c=t.vertexAttributes.position,s=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,u=new Float64Array(c.length),b=Object(o.j)(s)?new Float32Array(s.length):null,f=Object(o.j)(l)?new Float32Array(l.length):null;Object(w.d)(i,a,it,i),Object(S.f)(at,it);const p=ot;Object(N.z)(Object(m.b)(ot),Object(m.b)(e),at),p[3]=e[3],Object(U.f)(c,r,u),Object(o.j)(s)&&Object(U.c)(s,c,u,r,b),Object(o.j)(l)&&Object(U.e)(l,c,u,r,f),et(u,p,3,a),Object(U.a)(u,c,r),Object(o.j)(s)&&(et(b,p,3),Object(U.b)(b,c,u,r,s)),Object(o.j)(l)&&(et(f,p,4),Object(U.d)(f,c,u,r,l)),t.vertexAttributesChanged()}(t,e,r):function(t,e,n){const r=ct;if(!Object(w.u)(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,Q.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}et(t.vertexAttributes.position,e,3,r),et(t.vertexAttributes.normal,e,3),et(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}(t,e,r)}}function et(t,e,n,r=j.b){if(!Object(o.i)(t)){Object(K.i)(it),Object(K.c)(it,it,Object(m.a)(e),Object(m.b)(e));for(let e=0;e<t.length;e+=n){for(let n=0;n<3;n++)nt[n]=t[e+n]-r[n];Object(N.s)(nt,nt,it);for(let n=0;n<3;n++)t[e+n]=nt[n]+r[n]}}}const nt=Object(j.e)(),rt=Object(j.e)(),ot=Object(m.d)(),it=Object(k.d)(),at=Object(I.b)(),ct=Object(j.e)(),st=l.a.getLogger("esri.geometry.support.meshUtils.scale");function lt(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;if(Object(o.j)(t.transform)){var i;null!=(null==n?void 0:n.geographic)&&n.geographic!==t.transform.geographic&&st.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=null!=(i=null==n?void 0:n.origin)?i:t.transform.getOriginPoint(r);!function(t,e,n){const r=Object(N.y)(bt,n.x,n.y,n.z),o=Object(N.l)(bt,r,t.origin);t.applyLocalInverse(o,ft);const i=Object(N.g)(Object(j.e)(),t.scale,e);t.scale=i,t.applyLocalInverse(o,o),Object(N.l)(o,o,ft),t.translation=Object(N.h)(Object(j.e)(),t.translation,o)}(t.transform,e,o)}else{const r=Object(A.a)(t.spatialReference,n),i=n&&n.origin||t.origin;r?function(t,e,n){const r=t.spatialReference,i=Object($.g)(r),a=pt;Object(w.u)(n,a,i)||Object(w.u)(t.origin,a,i);const c=t.vertexAttributes.position,s=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,u=new Float64Array(c.length),b=Object(o.j)(s)?new Float32Array(s.length):null,f=Object(o.j)(l)?new Float32Array(l.length):null;Object(U.f)(c,r,u),Object(o.j)(s)&&Object(U.c)(s,c,u,r,b),Object(o.j)(l)&&Object(U.e)(l,c,u,r,f),ut(u,e,a),Object(U.a)(u,c,r),Object(o.j)(s)&&Object(U.b)(b,c,u,r,s),Object(o.j)(l)&&Object(U.d)(f,c,u,r,l),t.vertexAttributesChanged()}(t,e,i):function(t,e,n){const r=pt;if(!Object(w.u)(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,st.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}ut(t.vertexAttributes.position,e,r),t.vertexAttributesChanged()}(t,e,i)}}function ut(t,e,n=j.b){if(t)for(let r=0;r<t.length;r+=3){for(let e=0;e<3;e++)bt[e]=t[r+e]-n[e];Object(N.g)(bt,bt,e);for(let e=0;e<3;e++)t[r+e]=bt[e]+n[e]}}const bt=Object(j.e)(),ft=Object(j.e)(),pt=Object(j.e)();var jt;const ht=l.a.getLogger("esri.geometry.Mesh");let gt=jt=class extends(s.a.LoadableMixin(Object(u.b)(h.a))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new x.a,this.type="mesh"}initialize(){(Object(o.i)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded")}get hasExtent(){return!this.loaded&&Object(o.j)(this.external)&&Object(o.j)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,e=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new i.a({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e}),center:new g.a({x:0,y:0,z:0,spatialReference:e})};const n=Object(o.j)(this.transform)?this.transform.project(t,e):t;let r=1/0,a=1/0,c=1/0,s=-1/0,l=-1/0,u=-1/0,b=0,f=0,p=0;const j=n.length,h=1/(j/3);let O=0;for(;O<j;){const t=n[O++],e=n[O++],o=n[O++];r=Math.min(r,t),a=Math.min(a,e),c=Math.min(c,o),s=Math.max(s,t),l=Math.max(l,e),u=Math.max(u,o),b+=h*t,f+=h*e,p+=h*o}return{extent:new i.a({xmin:r,ymin:a,zmin:c,xmax:s,ymax:l,zmax:u,spatialReference:e}),center:new g.a({x:b,y:f,z:p,spatialReference:e})}}get anchor(){if(Object(o.j)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new g.a({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return Object(o.j)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&Object(o.j)(this.external)&&Object(o.j)(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(d.a.from(t)),this.notifyChange("components")):ht.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}ht.error("removeComponent()","Provided component is not part of the list of components")}else ht.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,e,n,r){return Object(m.e)(Ot.x,t,mt),Object(m.e)(Ot.y,e,dt),Object(m.e)(Ot.z,n,yt),Object(m.c)(mt,dt,mt),Object(m.c)(mt,yt,mt),tt(this,mt,r),this}offset(t,e,n,r){return this.loaded?(xt[0]=t,xt[1]=e,xt[2]=n,G(this,xt,r),this):(ht.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,e){return this.loaded?(lt(this,t,e),this):(ht.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,e){return this.loaded?(M(this,t,e),this):(ht.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return Object(o.j)(this.external)&&this.addResolvingPromise(async function(t,e,r){const{loadGLTFMesh:i}=await Object(b.A)(n.e(30).then(n.bind(null,1143)),r),a=await L(e,r),c=i(new g.a({x:0,y:0,z:0,spatialReference:t.spatialReference}),a.url,{resolveFile:E(a),useTransform:!0,signal:Object(o.j)(r)?r.signal:null});c.then((()=>a.dispose()),(()=>a.dispose()));const{vertexAttributes:s,components:l}=await c;t.vertexAttributes=s,t.components=l}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,e=this.components?new Map:null,n={components:this.components?this.components.map((n=>n.cloneWithDeduplication(t,e))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:Object(o.j)(this.transform)?this.transform.clone():null,external:Object(o.j)(this.external)?{source:this.external.source,extent:Object(o.j)(this.external.extent)?this.external.extent.clone():null}:null};return new jt(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await n.e(152).then(n.bind(null,1159));return e(this,t)}static createBox(t,e){if(!(t instanceof g.a))return ht.error(".createBox()","expected location to be a Point instance"),null;const n=new jt(q(function(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:n}=W,r=4*t.length,o=new Float64Array(3*r),i=new Float32Array(3*r),a=new Float32Array(2*r),c=new Uint32Array(2*t.length*3);let s=0,l=0,u=0,b=0;for(let f=0;f<t.length;f++){const r=t[f],p=s/3;for(const t of e)c[b++]=p+t;const j=r.corners;for(let t=0;t<4;t++){const e=j[t];let c=0;a[u++]=.25*n[t][0]+r.uvOrigin[0],a[u++]=r.uvOrigin[1]-.25*n[t][1];for(let t=0;t<3;t++)0!==r.axis[t]?(o[s++]=.5*r.axis[t],i[l++]=r.axis[t]):(o[s++]=.5*e[c++],i[l++]=0)}}return{position:o,normal:i,uv:a,faces:c}}(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?function(t,e){const n=t.components[0],r=n.faces,i=X[e],a=6*i,c=new Uint32Array(6),s=new Uint32Array(r.length-6);let l=0,u=0;for(let o=0;o<r.length;o++)o>=a&&o<a+6?c[l++]=r[o]:s[u++]=r[o];if(Object(o.j)(t.vertexAttributes.uv)){const e=new Float32Array(t.vertexAttributes.uv),n=4*i*2,r=[0,1,1,1,1,0,0,0];for(let t=0;t<r.length;t++)e[n+t]=r[t];t.vertexAttributes.uv=e}return t.components=[new d.a({faces:c,material:n.material}),new d.a({faces:s})],t}(n,e.imageFace):n}static createSphere(t,e){return t instanceof g.a?new jt(q(function(t=0){const e=Math.round(8*2**t),n=2*e,r=(e-1)*(n+1)+2*n,o=new Float64Array(3*r),i=new Float32Array(3*r),a=new Float32Array(2*r),c=new Uint32Array((e-1)*n*2*3);let s=0,l=0,u=0,b=0;for(let f=0;f<=e;f++){const t=f/e*Math.PI+.5*Math.PI,r=Math.cos(t),p=Math.sin(t);V[2]=p;const j=0===f||f===e,h=j?n-1:n;for(let g=0;g<=h;g++){const t=g/h*2*Math.PI;V[0]=-Math.sin(t)*r,V[1]=Math.cos(t)*r;for(let e=0;e<3;e++)o[s]=.5*V[e],i[s]=V[e],++s;a[l++]=(g+(j?.5:0))/n,a[l++]=f/e,0!==f&&g!==n&&(f!==e&&(c[u++]=b,c[u++]=b+1,c[u++]=b-n),1!==f&&(c[u++]=b,c[u++]=b-n,c[u++]=b-n-1)),b++}}return{position:o,normal:i,uv:a,faces:c}}(e&&e.densificationFactor||0),t,e)):(ht.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof g.a?new jt(q(function(t=0){const e=Math.round(16*2**t),n=4*(e+1)+2*e,r=new Float64Array(3*n),o=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(4*e*3);let c=0,s=0,l=0,u=0,b=0;for(let f=0;f<=5;f++){const t=0===f||5===f,n=f<=1||f>=4,p=2===f||4===f,j=t?e-1:e;for(let h=0;h<=j;h++){const g=h/j*2*Math.PI,O=t?0:.5;V[0]=O*Math.sin(g),V[1]=O*-Math.cos(g),V[2]=f<=2?.5:-.5;for(let t=0;t<3;t++)r[c++]=V[t],o[s++]=n?2===t?f<=1?1:-1:0:2===t?0:V[t]/O;i[l++]=(h+(t?.5:0))/e,i[l++]=f<=1?1*f/3:f<=3?1*(f-2)/3+1/3:1*(f-4)/3+2/3,p||0===f||h===e||(5!==f&&(a[u++]=b,a[u++]=b+1,a[u++]=b-e),1!==f&&(a[u++]=b,a[u++]=b-e,a[u++]=b-e-1)),b++}}return{position:r,normal:o,uv:i,faces:a}}(e&&e.densificationFactor||0),t,e)):(ht.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){return t instanceof g.a?new jt(q(function(t){const e=J.facingAxisOrderSwap[t],n=J.position,r=J.normal,o=new Float64Array(n.length),i=new Float32Array(r.length);let a=0;for(let c=0;c<4;c++){const t=a;for(let c=0;c<3;c++){const s=e[c],l=Math.abs(s)-1,u=s>=0?1:-1;o[a]=n[t+l]*u,i[a]=r[t+l]*u,a++}}return{position:o,normal:i,uv:new Float32Array(J.uv),faces:new Uint32Array(J.faces)}}(e&&e.facing||"up"),t,e)):(ht.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(t,e){if(!(t instanceof O.a))return ht.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=Object(v.b)(t);return new jt({vertexAttributes:new x.a({position:n.position}),components:[new d.a({faces:n.faces,shading:"flat",material:e&&e.material||null})],spatialReference:t.spatialReference})}static async createFromGLTF(t,e,r){if(!(t instanceof g.a))throw ht.error(".createfromGLTF()","expected location to be a Point instance"),new c.a("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await Object(b.A)(n.e(30).then(n.bind(null,1143)),r);return new jt(await o(t,e,r))}static createWithExternalSource(t,e,n){var r,o,i;const a=null!=(r=null==n?void 0:n.extent)?r:null,c=null!=(o=null==n?void 0:n.transform.clone())?o:new y.a;c.origin=[t.x,t.y,null!=(i=t.z)?i:0];const s=t.spatialReference;return new jt({external:{source:e,extent:a},transform:c,spatialReference:s})}static createIncomplete(t,e){var n,r;const o=null!=(n=null==e?void 0:e.transform.clone())?n:new y.a;o.origin=[t.x,t.y,null!=(r=t.z)?r:0];const i=t.spatialReference,a=new jt({transform:o,spatialReference:i});return a.addResolvingPromise(Promise.reject(new c.a("mesh-incomplete","Mesh resources are not complete"))),a}};Object(a.a)([Object(f.b)({type:[d.a],json:{write:!0}})],gt.prototype,"components",void 0),Object(a.a)([Object(f.b)({type:y.a,json:{write:!0}})],gt.prototype,"transform",void 0),Object(a.a)([Object(f.b)({constructOnly:!0})],gt.prototype,"external",void 0),Object(a.a)([Object(f.b)({readOnly:!0})],gt.prototype,"hasExtent",null),Object(a.a)([Object(f.b)({readOnly:!0})],gt.prototype,"boundingInfo",null),Object(a.a)([Object(f.b)({readOnly:!0})],gt.prototype,"anchor",null),Object(a.a)([Object(f.b)({readOnly:!0})],gt.prototype,"origin",null),Object(a.a)([Object(f.b)({readOnly:!0,json:{read:!1}})],gt.prototype,"extent",null),Object(a.a)([Object(f.b)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],gt.prototype,"hasZ",void 0),Object(a.a)([Object(f.b)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],gt.prototype,"hasM",void 0),Object(a.a)([Object(f.b)({type:x.a,nonNullable:!0,json:{write:!0}})],gt.prototype,"vertexAttributes",void 0),gt=jt=Object(a.a)([Object(p.a)("esri.geometry.Mesh")],gt);const Ot={x:Object(j.g)(1,0,0),y:Object(j.g)(0,1,0),z:Object(j.g)(0,0,1)},mt=Object(m.d)(),dt=Object(m.d)(),yt=Object(m.d)(),xt=Object(j.e)();var vt=gt,wt=n(204);function At(t,e,n){const i=n.features;n.features=[],delete n.geometryType;const a=wt.default.fromJSON(n);a.geometryType="mesh";const c=a.spatialReference,s=Object(o.i)(t.outFields)||!t.outFields.length?()=>({}):(l=t.outFields.includes("*")?null:new Set(t.outFields),({attributes:t})=>{if(!t)return{};if(!l)return t;for(const e in t)l.has(e)||delete t[e];return t});var l;for(const u of i){const t=Rt(u,c,e);Object(o.j)(t)&&a.features.push(new r.a({geometry:t,attributes:s(u)}))}return a}function Rt(t,e,n){const{status:r,source:o}=function(t){if(!t.assetMappings)return{status:0};const e=[],n=new Map;for(const r of t.assetMappings){const t=r.seqNo,o=r.assetName,i=r.assetURL,a=r.conversionStatus;if("FAILED"===a)return{status:0};if("COMPLETED"!==a)return{status:1};if(null==t)e.push({name:o,source:i});else{const r=n.get(o);let a;r?a=r.multipart:(a=[],e.push({name:o,source:{multipart:a}}),n.set(o,{multipart:a})),a[t]=i}}return{status:2,source:e}}(t);if(0===r)return null;const a=function({attributes:t},e,{transformFieldRoles:n}){return new g.a({x:t[n.originX],y:t[n.originY],z:t[n.originZ],spatialReference:e})}(t,e,n),c=i.a.fromJSON(t.geometry);c.spatialReference=e;const s=function({attributes:t,assetMappings:e},{transformFieldRoles:n}){var r;return new y.a({translation:[t[n.translationX],t[n.translationY],t[n.translationZ]],rotation:Object(m.e)([t[n.rotationX],t[n.rotationY],t[n.rotationZ]],t[n.rotationDeg]),scale:[t[n.scaleX],t[n.scaleY],t[n.scaleZ]],geographic:!(null!=(r=e.flags)&&r.includes("PROJECT_VERTICES"))})}(t,n);return 1===r?vt.createIncomplete(a,{extent:c,transform:s}):vt.createWithExternalSource(a,o,{extent:c,transform:s})}},757:function(t,e,n){"use strict";function r(t,e){var n;return t.isGeographic||t.isWebMercator&&(null==(n=null==e?void 0:e.geographic)||n)}n.d(e,"a",(function(){return r}))},776:function(t,e,n){"use strict";n.d(e,"a",(function(){return g})),n.d(e,"b",(function(){return O})),n.d(e,"c",(function(){return m})),n.d(e,"d",(function(){return d})),n.d(e,"e",(function(){return y}));var r=n(2),o=n(54),i=n(83),a=n(16),c=n(20),s=n(52),l=n(36),u=n(53),b=n(802),f=n(21),p=n(168),j=n(757),h=n(380);function g(t,e,n){return Object(j.a)(e.spatialReference,n)?function(t,e,n){const r=e.spatialReference,o=R(e,n,P),i=new Float64Array(t.position.length),a=function(t,e,n,r){Object(p.e)(f.v.fromTypedArray(r),f.v.fromTypedArray(t),e);const o=new Float64Array(t.length);return Object(h.a)(r,o,n)}(t.position,o,r,i),c=Object(s.a)(E,o);return{position:a,normal:x(a,i,t.normal,c,r),tangent:v(a,i,t.tangent,c,r)}}(t,e,n):function(t,e,n){const r=new Float64Array(t.position.length),o=t.position,i=e.x,a=e.y,c=e.z||0,{horizontal:s,vertical:l}=z(n?n.unit:null,e.spatialReference);for(let u=0;u<o.length;u+=3)r[u+0]=o[u+0]*s+i,r[u+1]=o[u+1]*s+a,r[u+2]=o[u+2]*l+c;return{position:r,normal:t.normal,tangent:t.tangent}}(t,e,n)}function O(t,e,n){const{position:o,normal:i,tangent:a}=t;if(Object(r.i)(e))return{position:o,normal:i,tangent:a};const c=e.localMatrix;return g({position:Object(h.h)(o,new Float64Array(o.length),c),normal:Object(r.j)(i)?Object(h.g)(i,new Float32Array(i.length),c):null,tangent:Object(r.j)(a)?Object(h.i)(a,new Float32Array(a.length),c):null},e.getOriginPoint(n),{geographic:e.geographic})}function m(t,e,n){if(null!=n&&n.useTransform){var r;const{position:o,normal:i,tangent:a}=t;return{vertexAttributes:{position:o,normal:i,tangent:a},transform:new b.a({origin:[e.x,e.y,null!=(r=e.z)?r:0],geographic:Object(j.a)(e.spatialReference,n)})}}return{vertexAttributes:g(t,e,n),transform:null}}function d(t,e,n){return Object(j.a)(e.spatialReference,n)?A(t,e,n):w(t,e,n)}function y(t,e,n,o){if(Object(r.i)(e))return d(t,n,o);const i=O(t,e,n.spatialReference);return n.equals(e.getOriginPoint(n.spatialReference))?w(i,n,o):Object(j.a)(n.spatialReference,o)?A(i,n,o):w(i,n,o)}function x(t,e,n,o,i){if(Object(r.i)(n))return null;const a=new Float32Array(n.length);return Object(p.a)(f.u.fromTypedArray(a),f.u.fromTypedArray(n),o),Object(h.b)(a,t,e,i,a),a}function v(t,e,n,o,i){if(Object(r.i)(n))return null;const a=new Float32Array(n.length);Object(p.a)(f.u.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT),f.u.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),o);for(let r=3;r<a.length;r+=4)a[r]=n[r];return Object(h.d)(a,t,e,i,a),a}function w(t,e,n){const r=new Float64Array(t.position.length),o=t.position,i=e.x,a=e.y,c=e.z||0,{horizontal:s,vertical:l}=z(n?n.unit:null,e.spatialReference);for(let u=0;u<o.length;u+=3)r[u+0]=(o[u+0]-i)/s,r[u+1]=(o[u+1]-a)/s,r[u+2]=(o[u+2]-c)/l;return{position:r,normal:t.normal,tangent:t.tangent}}function A(t,e,n){const r=e.spatialReference;R(e,n,P);const o=Object(a.a)(T,P),i=new Float64Array(t.position.length),c=function(t,e,n,r){const o=Object(h.f)(t,e,r),i=f.v.fromTypedArray(o),a=new Float64Array(o.length),c=f.v.fromTypedArray(a);return Object(p.e)(c,i,n),a}(t.position,r,o,i),l=Object(s.a)(E,o);return{position:c,normal:F(t.normal,t.position,i,r,l),tangent:M(t.tangent,t.position,i,r,l)}}function R(t,e,n){Object(l.d)(t.spatialReference,[t.x,t.y,t.z||0],n,Object(u.g)(t.spatialReference));const{horizontal:r,vertical:o}=z(e?e.unit:null,t.spatialReference);return Object(a.s)(n,n,[r,r,o]),n}function F(t,e,n,o,i){if(Object(r.i)(t))return null;const a=Object(h.c)(t,e,n,o,new Float32Array(t.length)),c=f.u.fromTypedArray(a);return Object(p.a)(c,c,i),a}function M(t,e,n,o,i){if(Object(r.i)(t))return null;const a=Object(h.e)(t,e,n,o,new Float32Array(t.length)),c=f.u.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT);return Object(p.a)(c,c,i),a}function z(t,e){if(Object(r.i)(t))return L;const n=e.isGeographic?1:Object(o.e)(e),i=e.isGeographic?1:Object(o.g)(e),a=Object(o.c)(1,t,"meters");return{horizontal:a*n,vertical:a*i}}const P=Object(c.d)(),T=Object(c.d)(),E=Object(i.b)(),L={horizontal:1,vertical:1}},777:function(t,e,n){"use strict";n.d(e,"a",(function(){return b})),n.d(e,"b",(function(){return u})),n.d(e,"c",(function(){return l})),n.d(e,"d",(function(){return c})),n.d(e,"e",(function(){return s}));var r=n(10),o=n(182),i=n(185),a=n(3);function c(t=f){return[t[0],t[1],t[2],t[3]]}function s(t,e,n=c()){return Object(a.m)(n,t),n[3]=e,n}function l(t,e,n=c()){return Object(o.h)(p,t,b(t)),Object(o.h)(j,e,b(e)),Object(o.f)(p,j,p),function(t,e){return t[3]=e,t}(n,Object(r.r)(Object(o.c)(n,p)))}function u(t){return t}function b(t){return Object(r.g)(t[3])}const f=[0,0,1,0],p=Object(i.b)(),j=Object(i.b)();c()},802:function(t,e,n){"use strict";var r,o=n(0),i=n(14),a=n(2),c=n(1),s=(n(8),n(9),n(7),n(4)),l=n(16),u=n(20),b=n(3),f=n(5),p=n(41),j=n(36),h=n(53),g=n(777),O=n(21),m=n(168),d=n(376);let y=r=class extends i.a{constructor(t){super(t),this.origin=Object(f.e)(),this.translation=Object(f.e)(),this.rotation=Object(g.d)(),this.scale=Object(f.g)(1,1,1),this.geographic=!0}get localMatrix(){const t=Object(u.d)();return Object(l.s)(t,t,this.scale),Object(l.c)(t,t,Object(g.a)(this.rotation),Object(g.b)(this.rotation)),Object(l.t)(t,t,this.translation),t}get localMatrixInverse(){return Object(l.a)(Object(u.d)(),this.localMatrix)}applyLocal(t,e){return Object(b.s)(e,t,this.localMatrix)}applyLocalInverse(t,e){return Object(b.s)(e,t,this.localMatrixInverse)}project(t,e){const n=new Float64Array(t.length),r=O.v.fromTypedArray(n),o=O.v.fromTypedArray(t);if(this.geographic){const t=Object(h.h)(Object(h.e)(e)),i=Object(u.d)();return Object(j.d)(e,this.origin,i,t),Object(l.m)(i,i,this.localMatrix),Object(m.e)(r,o,i),Object(j.q)(n,t,0,n,e,0,n.length/3),n}const{localMatrix:i,origin:a}=this;Object(l.f)(i,u.a)?Object(d.a)(r,o):Object(m.e)(r,o,i);for(let c=0;c<n.length;c+=3)n[c+0]+=a[0],n[c+1]+=a[1],n[c+2]+=a[2];return n}getOriginPoint(t){const[e,n,r]=this.origin;return new p.a({x:e,y:n,z:r,spatialReference:t})}equals(t){return Object(a.j)(t)&&this.geographic===t.geographic&&Object(b.q)(this.origin,t.origin)&&Object(l.g)(this.localMatrix,t.localMatrix)}clone(){const t={origin:Object(f.c)(this.origin),translation:Object(f.c)(this.translation),rotation:Object(g.d)(this.rotation),scale:Object(f.c)(this.scale),geographic:this.geographic};return new r(t)}};Object(o.a)([Object(c.b)({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"origin",void 0),Object(o.a)([Object(c.b)({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"translation",void 0),Object(o.a)([Object(c.b)({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"rotation",void 0),Object(o.a)([Object(c.b)({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"scale",void 0),Object(o.a)([Object(c.b)({type:Boolean,nonNullable:!0,json:{write:!0}})],y.prototype,"geographic",void 0),Object(o.a)([Object(c.b)()],y.prototype,"localMatrix",null),Object(o.a)([Object(c.b)()],y.prototype,"localMatrixInverse",null),y=r=Object(o.a)([Object(s.a)("esri.geometry.support.MeshTransform")],y);var x=y;e.a=x}}]);
//# sourceMappingURL=75.30d80479.chunk.js.map