(this["webpackJsonpjsapi-create-react-app"]=this["webpackJsonpjsapi-create-react-app"]||[]).push([[42],{1153:function(e,t,i){"use strict";i.r(t);var n=i(0),a=i(2),o=i(12),r=i(23),l=i(1),s=i(8),c=(i(9),i(7),i(4)),u=i(911),f=i(343),d=i(213),_=i(28),v=i(353),m=i(84),h=i(592),p=i(370),g=i(66),y=(i(93),i(109),i(145),i(228),i(47)),x=i(90),b=i(780);var S=class{constructor(e,t){this._width=0,this._height=0,this._free=[],this._width=e,this._height=t,this._free.push(new b.a(0,0,e,t))}get width(){return this._width}get height(){return this._height}allocate(e,t){if(e>this._width||t>this._height)return new b.a;let i=null,n=-1;for(let a=0;a<this._free.length;++a){const o=this._free[a];e<=o.width&&t<=o.height&&(null===i||o.y<=i.y&&o.x<=i.x)&&(i=o,n=a)}return null===i?new b.a:(this._free.splice(n,1),i.width<i.height?(i.width>e&&this._free.push(new b.a(i.x+e,i.y,i.width-e,t)),i.height>t&&this._free.push(new b.a(i.x,i.y+t,i.width,i.height-t))):(i.width>e&&this._free.push(new b.a(i.x+e,i.y,i.width-e,i.height)),i.height>t&&this._free.push(new b.a(i.x,i.y+t,e,i.height-t))),new b.a(i.x,i.y,e,t))}release(e){for(let t=0;t<this._free.length;++t){const i=this._free[t];if(i.y===e.y&&i.height===e.height&&i.x+i.width===e.x)i.width+=e.width;else if(i.x===e.x&&i.width===e.width&&i.y+i.height===e.y)i.height+=e.height;else if(e.y===i.y&&e.height===i.height&&e.x+e.width===i.x)i.x=e.x,i.width+=e.width;else{if(e.x!==i.x||e.width!==i.width||e.y+e.height!==i.y)continue;i.y=e.y,i.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)}};var C=class{constructor(e,t,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=t,this._glyphSource=i,this._binPack=new S(e-4,t-4),this._glyphData.push(new Uint8Array(e*t)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,t){const i=[],n=this._glyphSource,a=new Set;for(const r of t){const e=Math.floor(.00390625*r);a.add(e)}const o=[];return a.forEach((t=>{if(t<=256){const i=e+t;if(this._rangePromises.has(i))o.push(this._rangePromises.get(i));else{const a=n.getRange(e,t).then((()=>{this._rangePromises.delete(i)}),(()=>{this._rangePromises.delete(i)}));this._rangePromises.set(i,a),o.push(a)}}})),Promise.all(o).then((()=>{let a=this._glyphIndex[e];a||(a={},this._glyphIndex[e]=a);for(const o of t){const t=a[o];if(t){i[o]={sdf:!0,rect:t.rect,metrics:t.metrics,page:t.page,code:o};continue}const r=n.getGlyph(e,o);if(!r||!r.metrics)continue;const l=r.metrics;let s;if(0===l.width)s=new b.a(0,0,0,0);else{const e=3,t=l.width+2*e,i=l.height+2*e;let n=t%4?4-t%4:4,a=i%4?4-i%4:4;1===n&&(n=5),1===a&&(a=5),s=this._binPack.allocate(t+n,i+a),s.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new S(this.width-4,this.height-4),s=this._binPack.allocate(t+n,i+a));const o=this._glyphData[this._currentPage],c=r.bitmap;let u,f;if(c)for(let r=0;r<i;r++){u=t*r,f=this.width*(s.y+r+1)+s.x;for(let e=0;e<t;e++)o[f+e+1]=c[u+e]}}a[o]={rect:s,metrics:l,tileIDs:null,page:this._currentPage},i[o]={sdf:!0,rect:s,metrics:l,page:this._currentPage,code:o},this._dirties[this._currentPage]=!0}return i}))}removeGlyphs(e){for(const t in this._glyphIndex){const i=this._glyphIndex[t];if(!i)continue;let n;for(const t in i)if(n=i[t],n.tileIDs.delete(e),0===n.tileIDs.size){const e=this._glyphData[n.page],a=n.rect;let o,r;for(let t=0;t<a.height;t++)for(o=this.width*(a.y+t)+a.x,r=0;r<a.width;r++)e[o+r]=0;delete i[t],this._dirties[n.page]=!0}}}bind(e,t,i,n=0){this._textures[i]||(this._textures[i]=new y.a(e,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const a=this._textures[i];a.setSamplingMode(t),this._dirties[i]&&a.setData(this._glyphData[i]),e.bindTexture(a,n),this._dirties[i]=!1}dispose(){this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}},T=i(590);class w{constructor(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:{const t=e.getMessage();for(;t.next();)switch(t.tag()){case 3:{const e=t.getMessage();let i,n,a,o,r,l,s;for(;e.next();)switch(e.tag()){case 1:i=e.getUInt32();break;case 2:n=e.getBytes();break;case 3:a=e.getUInt32();break;case 4:o=e.getUInt32();break;case 5:r=e.getSInt32();break;case 6:l=e.getSInt32();break;case 7:s=e.getUInt32();break;default:e.skip()}e.release(),i&&(this._metrics[i]={width:a,height:o,left:r,top:l,advance:s},this._bitmaps[i]=n);break}default:t.skip()}t.release();break}default:e.skip()}}getMetrics(e){return this._metrics[e]}getBitmap(e){return this._bitmaps[e]}}class I{constructor(){this._ranges=[]}getRange(e){return this._ranges[e]}addRange(e,t){this._ranges[e]=t}}var D=class{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,t){const i=this._getFontStack(e);if(i.getRange(t))return Promise.resolve();const n=256*t,a=n+255,o=this._baseURL.replace("{fontstack}",e).replace("{range}",n+"-"+a);return Object(m.default)(o,{responseType:"array-buffer"}).then((e=>{i.addRange(t,new w(new T.a(new Uint8Array(e.data),new DataView(e.data))))})).catch((()=>{i.addRange(t,new w)}))}getGlyph(e,t){const i=this._getFontStack(e);if(!i)return;const n=Math.floor(t/256);if(n>256)return;const a=i.getRange(n);return a?{metrics:a.getMetrics(t),bitmap:a.getBitmap(t)}:void 0}_getFontStack(e){let t=this._glyphInfo[e];return t||(t=this._glyphInfo[e]=new I),t}},O=i(788);class z{constructor(e,t,i=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||t<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,i>0&&(this._maxItemSize=i),this._binPack=new S(e-4,t-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new S(this._pageWidth-4,this._pageHeight-4);const e=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),i=new Uint32Array(e*t);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,t=!1){let i,n,a=this._mosaicRects[e];if(a)return a;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(e&&e.startsWith("dasharray-")?([i,n]=this._rasterizeDash(e),t=!0):i=this._sprites.getSpriteInfo(e),!i||!i.width||!i.height||i.width<0||i.height<0)return null;const o=i.width,r=i.height,[l,s,c]=this._allocateImage(o,r);return l.width<=0?null:(this._copy(l,i,s,c,t,n),a={rect:l,width:o,height:r,sdf:i.sdf,simplePattern:!1,pixelRatio:i.pixelRatio,page:s},this._mosaicRects[e]=a,a)}getSpriteItems(e){const t={};for(const i of e)t[i.name]=this.getSpriteItem(i.name,i.repeat);return t}getMosaicItemPosition(e,t){const i=this.getSpriteItem(e,t),n=i&&i.rect;if(!n)return null;n.width=i.width,n.height=i.height;const a=i.width,o=i.height;return{tl:[n.x+2,n.y+2],br:[n.x+2+a,n.y+2+o],page:i.page}}bind(e,t,i=0,n=0){this._textures[i]||(this._textures[i]=new y.a(e,{pixelFormat:6408,dataType:5121,wrapMode:33071,width:this._size[i][0],height:this._size[i][1]},new Uint8Array(this._mosaicsData[i].buffer)));const a=this._textures[i];a.setSamplingMode(t),this._dirties[i]&&a.setData(new Uint8Array(this._mosaicsData[i].buffer)),e.bindTexture(a,n),this._dirties[i]=!1}static _copyBits(e,t,i,n,a,o,r,l,s,c,u){let f=n*t+i,d=l*o+r;if(u){d-=o;for(let r=-1;r<=c;r++,f=((r+c)%c+n)*t+i,d+=o)for(let t=-1;t<=s;t++)a[d+t]=e[f+(t+s)%s]}else for(let _=0;_<c;_++){for(let t=0;t<s;t++)a[d+t]=e[f+t];f+=t,d+=o}}_copy(e,t,i,n,a,o){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const r=new Uint32Array(o?o.buffer:this._sprites.image.buffer),l=this._mosaicsData[i];l&&r||console.error("Source or target images are uninitialized!");const s=o?t.width:this._sprites.width;z._copyBits(r,s,t.x,t.y,l,n[0],e.x+2,e.y+2,t.width,t.height,a),this._dirties[i]=!0}_allocateImage(e,t){e+=2,t+=2;const i=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<i){const i=new b.a(0,0,e,t);return this._mosaicsData.push(new Uint32Array(e*t)),this._dirties.push(!0),this._size.push([e,t]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[e,t]]}let n=e%4?4-e%4:4,a=t%4?4-t%4:4;1===n&&(n=5),1===a&&(a=5);const o=this._binPack.allocate(e+n,t+a);return o.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new S(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[o,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=e.match(/\[(.*?)\]/);if(!t)return null;const i=t[1].split(",").map(Number),n=e.slice(e.lastIndexOf("-")+1),[a,o,r]=O.c.rasterizeDash(i,n);return[{x:0,y:0,width:o,height:r,sdf:!0,pixelRatio:1},new Uint8Array(a.buffer)]}}var P=z,A=i(912);var E=i(574);const M=new h.a(10),V=new Map;var L=i(648),R=i(545),F=i(596);function U(e,t,i,n,a,o){const{iconRotationAlignment:r,textRotationAlignment:l,iconTranslate:s,iconTranslateAnchor:c,textTranslate:u,textTranslateAnchor:f}=n;let d=0;for(const _ of e.colliders){const[e,n]=0===_.partIndex?s:u,v=0===_.partIndex?c:f,m=_.minLod<=o&&o<=_.maxLod;d+=m?0:1,_.enabled=m,_.xScreen=_.xTile*a[0]+_.yTile*a[3]+a[6],_.yScreen=_.xTile*a[1]+_.yTile*a[4]+a[7],0===v?(_.xScreen+=i*e-t*n,_.yScreen+=t*e+i*n):(_.xScreen+=e,_.yScreen+=n),1===(0===_.partIndex?r:l)?(_.dxScreen=_.dxPixels,_.dyScreen=_.dyPixels):(_.dxScreen=i*(_.dxPixels+_.width/2)-t*(_.dyPixels+_.height/2)-_.width/2,_.dyScreen=t*(_.dxPixels+_.width/2)+i*(_.dyPixels+_.height/2)-_.height/2)}e.colliders.length>0&&d===e.colliders.length&&(e.unique.show=!1)}class N{constructor(e,t,i,n,a,o){this._symbols=e,this._styleRepository=n,this._zoom=a,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new F.a(t,i,R.a),this._si=Math.sin(Math.PI*o/180),this._co=Math.cos(Math.PI*o/180);for(const r of e)for(const e of r.symbols)this._allNeededMatrices.has(e.tile)||this._allNeededMatrices.set(e.tile,Object(d.a)(e.tile.transforms.tileUnitsToPixels))}work(e){const t=this._gridIndex;function i(e){const i=e.xScreen+e.dxScreen,n=e.yScreen+e.dyScreen,a=i+e.width,o=n+e.height,[r,l,s,c]=t.getCellSpan(i,n,a,o);for(let u=l;u<=c;u++)for(let e=r;e<=s;e++){const r=t.cells[u][e];for(const e of r){const t=e.xScreen+e.dxScreen,r=e.yScreen+e.dyScreen,l=t+e.width,s=r+e.height;if(!(a<t||i>l||o<r||n>s))return!0}}return!1}const n=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const t=this._symbols[this._currentLayerCursor],a=this._getProperties(t.styleLayerUID);for(;this._currentSymbolCursor<t.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-n>e)return!1;const o=t.symbols[this._currentSymbolCursor];if(!o.unique.show)continue;U(o,this._si,this._co,a,this._allNeededMatrices.get(o.tile),this._zoom);const r=o.unique;if(!r.show)continue;const{iconAllowOverlap:l,iconIgnorePlacement:s,textAllowOverlap:c,textIgnorePlacement:u}=a;for(const e of o.colliders){if(!e.enabled)continue;const t=r.parts[e.partIndex];t.show&&(!(e.partIndex?c:l)&&i(e)&&(e.hard?r.show=!1:t.show=!1))}if(r.show)for(const e of o.colliders){if(!e.enabled)continue;if(e.partIndex?u:s)continue;if(!r.parts[e.partIndex].show)continue;const t=e.xScreen+e.dxScreen,i=e.yScreen+e.dyScreen,n=t+e.width,a=i+e.height,[o,l,c,f]=this._gridIndex.getCellSpan(t,i,n,a);for(let r=l;r<=f;r++)for(let t=o;t<=c;t++)this._gridIndex.cells[r][t].push(e)}}}return!0}_getProperties(e){const t=this._styleProps.get(e);if(t)return t;const i=this._zoom,n=this._styleRepository.getStyleLayerByUID(e),a=0!==n.getLayoutValue("symbol-placement",i);let o=n.getLayoutValue("icon-rotation-alignment",i);2===o&&(o=a?0:1);let r=n.getLayoutValue("text-rotation-alignment",i);2===r&&(r=a?0:1);const l=n.getPaintValue("icon-translate",i),s=n.getPaintValue("icon-translate-anchor",i),c=n.getPaintValue("text-translate",i),u=n.getPaintValue("text-translate-anchor",i),f={iconAllowOverlap:n.getLayoutValue("icon-allow-overlap",i),iconIgnorePlacement:n.getLayoutValue("icon-ignore-placement",i),textAllowOverlap:n.getLayoutValue("text-allow-overlap",i),textIgnorePlacement:n.getLayoutValue("text-ignore-placement",i),iconRotationAlignment:o,textRotationAlignment:r,iconTranslateAnchor:s,iconTranslate:l,textTranslateAnchor:u,textTranslate:c};return this._styleProps.set(e,f),f}}function k(e,t){if(e.priority-t.priority)return e.priority-t.priority;const i=e.tile.key,n=t.tile.key;return i.world-n.world?i.world-n.world:i.level-n.level?i.level-n.level:i.row-n.row?i.row-n.row:i.col-n.col?i.col-n.col:e.xTile-t.xTile?e.xTile-t.xTile:e.yTile-t.yTile}class H{constructor(e,t,i,n,a,o){this._visibleTiles=e,this._symbolRepository=t,this._createCollisionJob=i,this._assignTileSymbolsOpacity=n,this._symbolLayerSorter=a,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}get running(){return this._running}setScreenSize(e,t){this._screenWidth===e&&this._screenHeight===t||this.restart(),this._screenWidth=e,this._screenHeight=t}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const t=performance.now();if(!this._selectionJob.work(e))return!1;if(this._selectionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const t=performance.now();if(!this._collisionJob.work(e))return!1;if(this._collisionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const t=performance.now();if(!this._opacityJob.work(e))return!1;if(this._opacityJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}return this._running=!1,!0}_createSelectionJob(){const e=this._symbolRepository.uniqueSymbols,t=[];let i=0,n=0;const a=this._isLayerVisible;const o=this._symbolLayerSorter;return{work:function(o){let r;const l=performance.now();for(;n<e.length;n++,i=0){const s=e[n],c=s.styleLayerUID;if(!a(c)){t[n]||(t[n]={styleLayerUID:c,symbols:[]});continue}t[n]=t[n]||{styleLayerUID:c,symbols:[]};const u=t[n];for(;i<s.uniqueSymbols.length;i++){if(r=s.uniqueSymbols[i],i%100==99&&performance.now()-l>o)return!1;let e=null,t=!1,n=!1;for(const i of r.tileSymbols)if(i.selectedForRendering=!1,!n||!t){const a=i.tile;(!e||a.isCoverage||a.neededForCoverage&&!t)&&(e=i,(a.neededForCoverage||a.isCoverage)&&(n=!0),a.isCoverage&&(t=!0))}if(e.selectedForRendering=!0,n){u.symbols.push(e),r.show=!0;for(const e of r.parts)e.show=!0}else r.show=!1}}for(const e of t)e.symbols.sort(k);return!0},get sortedSymbols(){return t.sort(o)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,t=this._visibleTiles;let i=0;function n(t,i){const a=t.symbols;for(const[e,n]of a)B(n,i);e(t,i);for(const e of t.childrenTiles)n(e,i)}return{work(e){const o=performance.now();for(;i<t.length;i++){if(performance.now()-o>e)return!1;const r=t[i];Object(a.j)(r.parentTile)||n(r,performance.now())}return!0}}}}function B(e,t){for(const i of e){const e=i.unique;for(const i of e.parts){const n=i.targetOpacity>.5?1:-1;i.startOpacity+=n*((t-i.startTime)/R.c),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=t,i.targetOpacity=e.show&&i.show?1:0}}}class j{constructor(e,t,i){this.tileCoordRange=e,this._visibleTiles=t,this._createUnique=i,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return Object(a.i)(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(e,t){this._uniqueSymbolLayerArray=null;let i=this._tiles.get(e.id);i||(i={symbols:new Map},this._tiles.set(e.id,i));const n=new Map;if(t)for(const r of t)i.symbols.has(r)&&(n.set(r,i.symbols.get(r)),i.symbols.delete(r));else for(const[r,l]of e.layerData)i.symbols.has(r)&&(n.set(r,i.symbols.get(r)),i.symbols.delete(r));this._removeSymbols(n);const a=e.symbols,o=new Map;for(const[r,l]of a){let e=l.length;if(e>=32){let t=this.tileCoordRange;do{t/=2,e/=4}while(e>8&&t>64);const n=new F.a(this.tileCoordRange,this.tileCoordRange,t);o.set(r,{flat:l,index:n}),i.symbols.set(r,{flat:l,index:n});for(const e of l)n.getCell(e.xTile,e.yTile).push(e)}else o.set(r,{flat:l}),i.symbols.set(r,{flat:l})}this._addSymbols(e.key,a)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[t,i]of this._tiles){const n=new Map;for(const t of e)i.symbols.has(t)&&(n.set(t,i.symbols.get(t)),i.symbols.delete(t));this._removeSymbols(n),0===i.symbols.size&&this._tiles.delete(t)}}removeTile(e){this._uniqueSymbolLayerArray=null;const t=this._tiles.get(e.id);if(!t)return;const i=new Map;for(const[n,a]of e.symbols)t.symbols.has(n)&&(i.set(n,t.symbols.get(n)),t.symbols.delete(n));this._removeSymbols(i),0===t.symbols.size&&this._tiles.delete(e.id)}_removeSymbols(e){for(const[t,{flat:i}]of e)for(const e of i){const i=e.unique,n=i.tileSymbols,a=n.length-1;for(let t=0;t<a;t++)if(n[t]===e){n[t]=n[a];break}if(n.length=a,0===a){const e=this._uniqueSymbolsReferences.get(t);e.delete(i),0===e.size&&this._uniqueSymbolsReferences.delete(t)}e.unique=null}}_addSymbols(e,t){if(0===t.size)return;const i=this._visibleTiles;for(const n of i)n.parentTile||n.key.world!==e.world||n.key.level===e.level&&!n.key.equals(e)||this._matchSymbols(n,e,t);for(const[n,o]of t)for(const e of o)if(Object(a.i)(e.unique)){const t=this._createUnique();e.unique=t,t.tileSymbols.push(e);let i=this._uniqueSymbolsReferences.get(n);i||(i=new Set,this._uniqueSymbolsReferences.set(n,i)),i.add(t)}}_matchSymbols(e,t,i){if(e.key.level>t.level){const i=e.key.level-t.level;if(e.key.row>>i!==t.row||e.key.col>>i!==t.col)return}if(t.level>e.key.level){const i=t.level-e.key.level;if(t.row>>i!==e.key.row||t.col>>i!==e.key.col)return}if(t.equals(e.key)){for(const n of e.childrenTiles)this._matchSymbols(n,t,i);return}const n=new Map;for(const[o,r]of i){const i=[];for(const n of r){const a=Object(F.c)(this.tileCoordRange,n.xTile,t.level,t.col,e.key.level,e.key.col),o=Object(F.c)(this.tileCoordRange,n.yTile,t.level,t.row,e.key.level,e.key.row);a>=0&&a<this.tileCoordRange&&o>=0&&o<this.tileCoordRange&&i.push({symbol:n,xTransformed:a,yTransformed:o})}const l=[],s=e.key.level<t.level?1:1<<e.key.level-t.level,c=this._tiles.get(e.id).symbols.get(o);if(c){const e=c.flat;for(const t of i){let i,n=!1;const o=t.xTransformed,r=t.yTransformed;i=Object(a.j)(c.index)?c.index.getCell(o,r):e;const u=t.symbol,f=u.hash;for(const e of i)if(f===e.hash&&Math.abs(o-e.xTile)<=s&&Math.abs(r-e.yTile)<=s){const t=e.unique;u.unique=t,t.tileSymbols.push(u),n=!0;break}n||l.push(u)}}l.length>0&&n.set(o,l)}for(const a of e.childrenTiles)this._matchSymbols(a,t,n)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,t=new Array(e.size);let i,n=0;for(const[a,o]of e){const e=new Array(o.size);i=0;for(const t of o)e[i++]=t;t[n]={styleLayerUID:a,uniqueSymbols:e},n++}return t}}var G=class extends class{constructor(e,t,i){this._vectorTileLayer=e,this._styleRepository=t,this.devicePixelRatio=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(e){const t=this._vectorTileLayer,i=t.sourceNameToSource,n=[];for(const r in i)n.push(this._fetchTileMap(i[r],e));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,e),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new P(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const a=this._styleRepository,o=new D(a.glyphs);return this._glyphMosaic=new C(1024,1024,o),this._broadcastPromise=Object(p.b)("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then((i=>(this._connection=i,Promise.all(this._connection.broadcast("setStyle",{style:t.currentStyleInfo.style,vectorTileLayerMaxBuffers:Object(s.a)("vectortilelayer-max-buffers")},e))))),Promise.all(n)}async updateStyle(e){return await this._broadcastPromise,this._broadcastPromise=new Promise(((t,i)=>{Promise.all(this._connection.broadcast("updateStyle",e)).then(t,i)})),this._broadcastPromise}async setStyle(e,t){await this._broadcastPromise,this._styleRepository=e;const i=this._vectorTileLayer.sourceNameToSource,n=[];for(const o in i)n.push(this._fetchTileMap(i[o],null));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new P(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const a=new D(e.glyphs);return this._glyphMosaic=new C(1024,1024,a),this._broadcastPromise=new Promise(((e,i)=>{Promise.all(this._connection.broadcast("setStyle",{style:t,vectorTileLayerMaxBuffers:Object(s.a)("vectortilelayer-max-buffers")})).then(e,i)})),n.push(this._broadcastPromise),Promise.all(n)}fetchTileData(e,t){return this._getRefKeys(e,t).then((e=>{const i=this._vectorTileLayer.sourceNameToSource,n=[];for(const t in i)n.push(t);return this._getSourcesData(n,e,t)}))}parseTileData(e,t){const i=e&&e.data;if(!i)return Promise.resolve(null);const{sourceName2DataAndRefKey:n,transferList:a}=i;return 0===Object.keys(n).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((i=>i.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:n,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:a}).then((e=>({tileData:e})))))))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}perfReport({key:e,milliseconds:t}){!function(e,t,i){if(!window.PERFORMANCE_RECORDING_STORAGE)return;const n=window.PERFORMANCE_RECORDING_STORAGE;n.perf=n.perf||{};const a=n.perf;a[e]=a[e]||{start:null,time:0,min:void 0,max:void 0,samples:[],unit:i},a[e].time+=t,a[e].samples.push(t),(null==a[e].min||t<a[e].min)&&(a[e].min=t),(null==a[e].max||t>a[e].max)&&(a[e].max=t)}(e,t,"ms")}async _getTilePayload(e,t,i){const n=E.a.pool.acquire(e.id),a=this._vectorTileLayer.sourceNameToSource[t].getSourceTileUrl(n.level,n.row,n.col);E.a.pool.release(n);try{return{protobuff:await this.request(a,i),sourceName:t}}catch(r){if(Object(o.n)(r))throw r;return{protobuff:null,sourceName:t}}}request(e,t){return Object(m.default)(e,{responseType:"array-buffer",...t}).then((({data:e})=>e))}async _fetchTileMap(e,t){if(e.capabilities.operations.supportsTileMap&&e.tileIndex)return Promise.resolve();if(!e.tileMapURL)return;const i=M.get(e.tileMapURL);if(i)return void(e.tileIndex=i);let n;if(V.has(e.tileMapURL)){try{n=await V.get(e.tileMapURL),e.tileIndex=new A.a(n.data)}catch(r){if(Object(o.n)(r))throw r}return}const a=Object(m.default)(e.tileMapURL,t);V.set(e.tileMapURL,a);try{n=await a,V.delete(e.tileMapURL),M.put(e.tileMapURL,e.tileIndex),e.tileIndex=new A.a(n.data)}catch(r){if(V.delete(e.tileMapURL),Object(o.n)(r))throw r}}_getRefKeys(e,t){const i=this._vectorTileLayer.sourceNameToSource,n=new Array;for(const a in i){const o=i[a].getRefKey(e,t);n.push(o)}return Object(o.k)(n)}_getSourcesData(e,t,i){const n=[];for(let a=0;a<t.length;a++)if(null==t[a].value||null==e[a])n.push(null);else{const o=this._getTilePayload(t[a].value,e[a],i);n.push(o)}return Object(o.k)(n).then((e=>{const i={},n=[];for(let a=0;a<e.length;a++)if(e[a].value&&e[a].value&&e[a].value.protobuff&&e[a].value.protobuff.byteLength>0){const o=t[a].value.id;i[e[a].value.sourceName]={refKey:o,protobuff:e[a].value.protobuff},n.push(e[a].value.protobuff)}return{sourceName2DataAndRefKey:i,transferList:n}}))}}{constructor(e,t,i,n,a){super(e,t,i),this._memCache=n,this._loader=a,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map}destroy(){this._ongoingRequestToController.forEach((e=>e.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(e,t,i,n){const r=new E.a(e,t,i,0);let l=this._memCache.get(r.id);if(Object(a.j)(l))return l.retain(),l;const s=await this._getVectorTileData(r);if(Object(o.x)(n),!this._vectorTileLayer)return null;if(l=this._memCache.get(r.id),Object(a.j)(l))return l.retain(),l;const c=this._vectorTileLayer.tileInfo.getTileBounds(Object(_.k)(),r);return l=new v.a(r,this._styleRepository,c,[512,512],this._memCache),Object(a.j)(s)&&s.tileData?(l.setData(s.tileData),l.retain(),this._memCache.put(r.id,l,l.memoryUsage*l.referenced,f.a)):l.setData(null),l.neededForCoverage=!0,l.transforms.tileUnitsToPixels=Object(d.c)(1/8,0,0,0,1/8,0,0,0,1),function(e,t){const i=[],n=new j(4096,i,(()=>{const e=new L.b;return e.show=!1,e.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),e.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),e})),a=new H(i,n,((t,i,n)=>new N(t,i,n,e.styleRepository,e.key.level,0)),((e,t)=>{Object(F.d)(e,t,!1)}),(()=>0),(e=>{const i=t.getStyleLayerByUID(e).getLayoutProperty("visibility");return!i||1!==i.getValue()}));i.push(e),n.add(e),a.setScreenSize(512,512),a.continue(1/0)}(l,this._styleRepository),l}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,n={signal:i.signal},a=this._getParsedVectorTileData(e,n).then((e=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),e))).catch((()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null)));return this._ongoingTileRequests.set(t,a),this._ongoingRequestToController.set(t,i),a}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then((i=>this.parseTileData({key:e,data:i},t)))}request(e,t){return this._loader.request(e,"binary",t)}},W=i(699);var q=class{constructor(){this.name=this.constructor.name||"UnnamedBrush"}prepareState(e,t,i){}draw(e,t,i){}drawMany(e,t,i){for(const n of t)this.draw(e,n,i)}};var Z=i(192);i(719);var Y=class{constructor(e){this.readFile=e}resolveIncludes(e){return this.resolve(e)}resolve(e,t=new Map){if(t.has(e))return t.get(e);const i=this.read(e);if(!i)throw new Error(`cannot find shader file ${e}`);const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let a=n.exec(i);const o=[];for(;null!=a;)o.push({path:a[1],start:a.index,length:a[0].length}),a=n.exec(i);let r=0,l="";return o.forEach((e=>{l+=i.slice(r,e.start),l+=t.has(e.path)?"":this.resolve(e.path,t),r=e.start+e.length})),l+=i.slice(r),t.set(e,l),l}read(e){return this.readFile(e)}},X={background:{"background.frag":"uniform lowp vec4 u_color;\nvoid main() {\ngl_FragColor = u_color;\n}","background.vert":"attribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump vec2 u_coord_range;\nuniform mediump float u_depth;\nvoid main() {\nvec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\ngl_Position = vec4(v_pos.xy, 0.0, 1.0);\n}"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\nvarying mediump vec2 v_uv;\nvoid main() {\nlowp vec4 color = texture2D(u_tex, v_uv);\ngl_FragColor = color *  u_opacity;\n}","bitBlit.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\nvarying mediump vec2 v_uv;\nvoid main(void) {\ngl_Position = vec4(a_pos, 0.0, 1.0);\nv_uv = a_tex;\n}"},blend:{"blend.frag":"precision mediump float;\nuniform sampler2D u_layerTexture;\nuniform lowp float u_opacity;\nuniform lowp float u_inFadeOpacity;\n#ifndef NORMAL\nuniform sampler2D u_backbufferTexture;\n#endif\nvarying mediump vec2 v_uv;\nfloat rgb2v(in vec3 c) {\nreturn max(c.x, max(c.y, c.z));\n}\nvec3 rgb2hsv(in vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\nvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\nfloat d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n}\nvec3 hsv2rgb(in vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 tint(in vec3 Cb, in vec3 Cs) {\nfloat vIn = rgb2v(Cb);\nvec3 hsvTint = rgb2hsv(Cs);\nvec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);\nreturn hsv2rgb(hsvOut);\n}\nfloat overlay(in float Cb, in float Cs) {\nreturn (1.0 - step(0.5, Cs)) * (1.0 - 2.0 * (1.0 - Cs ) * (1.0 - Cb)) + step(0.5, Cs) * (2.0 * Cs * Cb);\n}\nfloat colorDodge(in float Cb, in float Cs) {\nreturn (Cb == 0.0) ? 0.0 : (Cs == 1.0) ? 1.0 : min(1.0, Cb / (1.0 - Cs));\n}\nfloat colorBurn(in float Cb, in float Cs) {\nreturn (Cb == 1.0) ? 1.0 : (Cs == 0.0) ? 0.0 : 1.0 - min(1.0, (1.0 - Cb) / Cs);\n}\nfloat hardLight(in float Cb, in float Cs) {\nreturn (1.0 - step(0.5, Cs)) * (2.0 * Cs * Cb) + step(0.5, Cs) * (1.0 - 2.0 * (1.0 - Cs) * (1.0 - Cb));\n}\nfloat reflectBlend(in float Cb, in float Cs) {\nreturn (Cs == 1.0) ? Cs : min(Cb * Cb / (1.0 - Cs), 1.0);\n}\nfloat softLight(in float Cb, in float Cs) {\nif (Cs <= 0.5) {\nreturn Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);\n}\nif (Cb <= 0.25) {\nreturn Cb + (2.0 * Cs - 1.0) * Cb * ((16.0 * Cb - 12.0) * Cb + 3.0);\n}\nreturn Cb + (2.0 * Cs - 1.0) * (sqrt(Cb) - Cb);\n}\nfloat vividLight(in float Cb, in float Cs) {\nreturn (1.0 - step(0.5, Cs)) * colorBurn(Cb, 2.0 * Cs) + step(0.5, Cs) * colorDodge(Cb, (2.0 * (Cs - 0.5)));\n}\nfloat minv3(in vec3 c) {\nreturn min(min(c.r, c.g), c.b);\n}\nfloat maxv3(in vec3 c) {\nreturn max(max(c.r, c.g), c.b);\n}\nfloat lumv3(in vec3 c) {\nreturn dot(c, vec3(0.3, 0.59, 0.11));\n}\nfloat satv3(vec3 c) {\nreturn maxv3(c) - minv3(c);\n}\nvec3 clipColor(vec3 color) {\nfloat lum = lumv3(color);\nfloat mincol = minv3(color);\nfloat maxcol = maxv3(color);\nif (mincol < 0.0) {\ncolor = lum + ((color - lum) * lum) / (lum - mincol);\n}\nif (maxcol > 1.0) {\ncolor = lum + ((color - lum) * (1.0 - lum)) / (maxcol - lum);\n}\nreturn color;\n}\nvec3 setLum(vec3 cbase, vec3 clum) {\nfloat lbase = lumv3(cbase);\nfloat llum = lumv3(clum);\nfloat ldiff = llum - lbase;\nvec3 color = cbase + vec3(ldiff);\nreturn clipColor(color);\n}\nvec3 setLumSat(vec3 cbase, vec3 csat, vec3 clum)\n{\nfloat minbase = minv3(cbase);\nfloat sbase = satv3(cbase);\nfloat ssat = satv3(csat);\nvec3 color;\nif (sbase > 0.0) {\ncolor = (cbase - minbase) * ssat / sbase;\n} else {\ncolor = vec3(0.0);\n}\nreturn setLum(color, clum);\n}\nvoid main() {\nvec4 src = texture2D(u_layerTexture, v_uv);\n#ifdef NORMAL\ngl_FragColor = src *  u_opacity;\n#else\nvec4 dst = texture2D(u_backbufferTexture, v_uv);\nvec3 Cs = src.a == 0.0 ? src.rgb : vec3(src.rgb / src.a);\nvec3 Cb = dst.a == 0.0 ? dst.rgb : vec3(dst.rgb / dst.a);\nfloat as = u_opacity * src.a;\nfloat ab = dst.a;\n#ifdef DESTINATION_OVER\ngl_FragColor = vec4(as * Cs * (1.0 - ab) + ab * Cb, as + ab - as * ab);\n#endif\n#ifdef SOURCE_IN\nvec4 color = vec4(as * Cs * ab, as * ab);\nvec4 fadeColor = (1.0 - u_opacity) * u_inFadeOpacity * vec4(ab * Cb, ab);\ngl_FragColor = color + fadeColor;\n#endif\n#ifdef DESTINATION_IN\nvec4 color = vec4(ab * Cb * as, ab * as);\nvec4 fadeColor = (1.0 - u_opacity) * u_inFadeOpacity * vec4(ab * Cb, ab);\ngl_FragColor = color + fadeColor;\n#endif\n#ifdef SOURCE_OUT\ngl_FragColor = vec4(as * Cs * (1.0 - ab), as * (1.0 - ab));\n#endif\n#ifdef DESTINATION_OUT\ngl_FragColor = vec4(ab * Cb * (1.0 - as), ab * (1.0 - as));\n#endif\n#ifdef SOURCE_ATOP\ngl_FragColor = vec4(as * Cs * ab + ab * Cb * (1.0 - as), ab);\n#endif\n#ifdef DESTINATION_ATOP\ngl_FragColor = vec4(as * Cs * (1.0 - ab) + ab * Cb * as, as);\n#endif\n#ifdef XOR\ngl_FragColor = vec4(as * Cs * (1.0 - ab) + ab * Cb * (1.0 - as),\nas * (1.0 - ab) + ab * (1.0 - as));\n#endif\n#ifdef MULTIPLY\ngl_FragColor = vec4(as * Cs * ab * Cb + (1.0 - ab) * as * Cs + (1.0 - as) * ab * Cb,\nas + ab * (1.0 - as));\n#endif\n#ifdef SCREEN\ngl_FragColor = vec4((Cs + Cb - Cs * Cb) * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef OVERLAY\nvec3 f = vec3(overlay(Cb.r, Cs.r), overlay(Cb.g, Cs.g), overlay(Cb.b, Cs.b));\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef DARKEN\ngl_FragColor = vec4(min(Cs, Cb) * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef LIGHTER\ngl_FragColor = vec4(as * Cs + ab * Cb, as + ab);\n#endif\n#ifdef LIGHTEN\ngl_FragColor = vec4(max(Cs, Cb) * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef COLOR_DODGE\nvec3 f = vec3(colorDodge(Cb.r, Cs.r), colorDodge(Cb.g, Cs.g), colorDodge(Cb.b, Cs.b));\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef COLOR_BURN\nvec3 f = vec3(colorBurn(Cb.r, Cs.r), colorBurn(Cb.g, Cs.g), colorBurn(Cb.b, Cs.b));\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef HARD_LIGHT\nvec3 f = vec3(hardLight(Cb.r, Cs.r), hardLight(Cb.g, Cs.g), hardLight(Cb.b, Cs.b));\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef SOFT_LIGHT\nvec3 f = vec3(softLight(Cb.r, Cs.r), softLight(Cb.g, Cs.g), softLight(Cb.b, Cs.b));\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef DIFFERENCE\ngl_FragColor = vec4(abs(Cb - Cs) * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef EXCLUSION\nvec3 f = Cs + Cb - 2.0 * Cs * Cb;\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef INVERT\ngl_FragColor = vec4((1.0 - Cb) * as * ab + Cb * ab * (1.0 - as), ab);\n#endif\n#ifdef VIVID_LIGHT\nvec3 f = vec3(vividLight(Cb.r, Cs.r),\nvividLight(Cb.g, Cs.g),\nvividLight(Cb.b, Cs.b));\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef HUE\nvec3 f = setLumSat(Cs,Cb,Cb);\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef SATURATION\nvec3 f = setLumSat(Cb,Cs,Cb);\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef COLOR\nvec3 f = setLum(Cs,Cb);\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef LUMINOSITY\nvec3 f = setLum(Cb,Cs);\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef PLUS\ngl_FragColor = clamp(vec4(src.r + Cb.r, src.g + Cb.g, src.b + Cb.b, as + ab), 0.0, 1.0);\n#endif\n#ifdef MINUS\ngl_FragColor = vec4(clamp(vec3(Cb.r - src.r, Cb.g - src.g, Cb.b - src.b), 0.0, 1.0), ab * as);\n#endif\n#ifdef AVERAGE\nvec3 f = (Cb + Cs) / 2.0;\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#ifdef REFLECT\nvec3 f = vec3(reflectBlend(Cb.r, Cs.r),\nreflectBlend(Cb.g, Cs.g),\nreflectBlend(Cb.b, Cs.b));\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\nas + ab * (1.0 - as));\n#endif\n#endif\n}","blend.vert":"attribute vec2 a_position;\nvarying mediump vec2 v_uv;\nvoid main(void) {\ngl_Position = vec4(a_position , 0.0, 1.0);\nv_uv = (a_position + 1.0) / 2.0;\n}"},filtering:{"bicubic.glsl":"vec4 computeWeights(float v) {\nfloat b = 1.0 / 6.0;\nfloat v2 = v * v;\nfloat v3 = v2 * v;\nfloat w0 = b * (-v3 + 3.0 * v2 - 3.0 * v + 1.0);\nfloat w1 = b * (3.0 * v3  - 6.0 * v2 + 4.0);\nfloat w2 = b * (-3.0 * v3 + 3.0 * v2 + 3.0 * v + 1.0);\nfloat w3 = b * v3;\nreturn vec4(w0, w1, w2, w3);\n}\nvec4 bicubicOffsetsAndWeights(float v) {\nvec4 w = computeWeights(v);\nfloat g0 = w.x + w.y;\nfloat g1 = w.z + w.w;\nfloat h0 = 1.0 - (w.y / g0) + v;\nfloat h1 = 1.0 + (w.w / g1) - v;\nreturn vec4(h0, h1, g0, g1);\n}\nvec4 sampleBicubicBSpline(sampler2D sampler, vec2 coords, vec2 texSize) {\nvec2 eX = vec2(1.0 / texSize.x, 0.0);\nvec2 eY = vec2(0.0, 1.0 / texSize.y);\nvec2 texel = coords * texSize - 0.5;\nvec3 hgX = bicubicOffsetsAndWeights(fract(texel).x).xyz;\nvec3 hgY = bicubicOffsetsAndWeights(fract(texel).y).xyz;\nvec2 coords10 = coords + hgX.x * eX;\nvec2 coords00 = coords - hgX.y * eX;\nvec2 coords11 = coords10 + hgY.x * eY;\nvec2 coords01 = coords00 + hgY.x * eY;\ncoords10 = coords10 - hgY.y * eY;\ncoords00 = coords00 - hgY.y * eY;\nvec4 color00 = texture2D(sampler, coords00);\nvec4 color10 = texture2D(sampler, coords10);\nvec4 color01 = texture2D(sampler, coords01);\nvec4 color11 = texture2D(sampler, coords11);\ncolor00 = mix(color00, color01, hgY.z);\ncolor10 = mix(color10, color11, hgY.z);\ncolor00 = mix(color00, color10, hgX.z);\nreturn color00;\n}","bilinear.glsl":"vec4 sampleBilinear(sampler2D sampler, vec2 coords, vec2 texSize) {\nvec2 texelStart = floor(coords * texSize);\nvec2 coord0 = texelStart / texSize;\nvec2 coord1 = (texelStart +  vec2(1.0, 0.0)) / texSize;\nvec2 coord2 = (texelStart +  vec2(0.0, 1.0)) / texSize;\nvec2 coord3 = (texelStart +  vec2(1.0, 1.0)) / texSize;\nvec4 color0 = texture2D(sampler, coord0);\nvec4 color1 = texture2D(sampler, coord1);\nvec4 color2 = texture2D(sampler, coord2);\nvec4 color3 = texture2D(sampler, coord3);\nvec2 blend = fract(coords * texSize);\nvec4 color01 = mix(color0, color1, blend.x);\nvec4 color23 = mix(color2, color3, blend.x);\nreturn mix(color01, color23, blend.y);\n}","epx.glsl":"vec4 sampleEPX(sampler2D sampler, float size, vec2 coords, vec2 texSize) {\nvec2 invSize = 1.0 / texSize;\nvec2 texel = coords * texSize;\nvec2 texel_i = floor(texel);\nvec2 texel_frac = fract(texel);\nvec4 colorP = texture2D(sampler, texel_i * invSize);\nvec4 colorP1 = vec4(colorP);\nvec4 colorP2 = vec4(colorP);\nvec4 colorP3 = vec4(colorP);\nvec4 colorP4 = vec4(colorP);\nvec4 colorA = texture2D(sampler, (texel_i - vec2(0.0, 1.0)) * invSize);\nvec4 colorB = texture2D(sampler, (texel_i + vec2(1.0, 0.0)) * invSize);\nvec4 colorC = texture2D(sampler, (texel_i - vec2(1.0, 0.0)) * invSize);\nvec4 colorD = texture2D(sampler, (texel_i + vec2(0.0, 1.0)) * invSize);\nif (colorC == colorA && colorC != colorD && colorA != colorB) {\ncolorP1 = colorA;\n}\nif (colorA == colorB && colorA != colorC && colorB != colorD) {\ncolorP2 = colorB;\n}\nif (colorD == colorC && colorD != colorB && colorC != colorA) {\ncolorP3 = colorC;\n}\nif (colorB == colorD && colorB != colorA && colorD != colorC) {\ncolorP4 = colorD;\n}\nvec4 colorP12 = mix(colorP1, colorP2, texel_frac.x);\nvec4 colorP34 = mix(colorP1, colorP2, texel_frac.x);\nreturn mix(colorP12, colorP34, texel_frac.y);\n}"},fx:{integrate:{"integrate.frag":"precision mediump float;\nuniform lowp sampler2D u_sourceTexture;\nuniform lowp sampler2D u_maskTexture;\nuniform mediump float u_zoomLevel;\nuniform highp float u_timeDelta;\nuniform highp float u_animationTime;\nvarying highp vec2 v_texcoord;\n#include <materials/utils.glsl>\nvoid main()\n{\n#ifdef DELTA\nvec4 texel = texture2D(u_sourceTexture, v_texcoord);\nvec4 data0 = texture2D(u_maskTexture, v_texcoord);\nfloat flags = data0.r * 255.0;\nfloat groupMinZoom = data0.g * 255.0;\nfloat isVisible = getFilterBit(flags, 0);\nfloat wouldClip = step(groupMinZoom, u_zoomLevel);\nfloat direction = wouldClip * 1.0 + (1.0 - wouldClip) * -1.0;\nfloat dt = u_timeDelta / max(u_animationTime, 0.0001);\nvec4 nextState = vec4(texel + direction * dt);\ngl_FragColor =  vec4(nextState);\n#elif defined(UPDATE)\nvec4 texel = texture2D(u_sourceTexture, v_texcoord);\ngl_FragColor = texel;\n#endif\n}","integrate.vert":"precision mediump float;\nattribute vec2 a_pos;\nvarying highp vec2 v_texcoord;\nvoid main()\n{\nv_texcoord = a_pos;\ngl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n}"}},highlight:{"blur.frag":"varying mediump vec2 v_texcoord;\nuniform mediump vec4 u_direction;\nuniform mediump mat4 u_channelSelector;\nuniform mediump float u_sigma;\nuniform sampler2D u_texture;\nmediump float gauss1(mediump vec2 dir) {\nreturn exp(-dot(dir, dir) / (2.0 * u_sigma * u_sigma));\n}\nmediump vec4 selectChannel(mediump vec4 sample) {\nreturn u_channelSelector * sample;\n}\nvoid accumGauss1(mediump float i, inout mediump float tot, inout mediump float weight) {\nmediump float w = gauss1(i * u_direction.xy);\ntot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw))[3] * w;\nweight += w;\n}\nvoid main(void) {\nmediump float tot = 0.0;\nmediump float weight = 0.0;\naccumGauss1(-5.0, tot, weight);\naccumGauss1(-4.0, tot, weight);\naccumGauss1(-3.0, tot, weight);\naccumGauss1(-2.0, tot, weight);\naccumGauss1(-1.0, tot, weight);\naccumGauss1(0.0, tot, weight);\naccumGauss1(1.0, tot, weight);\naccumGauss1(2.0, tot, weight);\naccumGauss1(3.0, tot, weight);\naccumGauss1(4.0, tot, weight);\naccumGauss1(5.0, tot, weight);\ngl_FragColor = vec4(0.0, 0.0, 0.0, tot / weight);\n}","highlight.frag":"varying mediump vec2 v_texcoord;\nuniform sampler2D u_texture;\nuniform mediump float u_sigma;\nuniform sampler2D u_shade;\nuniform mediump vec2 u_minMaxDistance;\nmediump float estimateDistance() {\nmediump float y = texture2D(u_texture, v_texcoord)[3];\nconst mediump float y0 = 0.5;\nmediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * u_sigma);\nmediump float d = (y - y0) / m0;\nreturn d;\n}\nmediump vec4 shade(mediump float d) {\nmediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\nmappedDistance = clamp(mappedDistance, 0.0, 1.0);\nreturn texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\nvoid main(void) {\nmediump float d = estimateDistance();\ngl_FragColor = shade(d);\n}","textured.vert":"attribute mediump vec2 a_position;\nattribute mediump vec2 a_texcoord;\nvarying mediump vec2 v_texcoord;\nvoid main(void) {\ngl_Position = vec4(a_position, 0.0, 1.0);\nv_texcoord = a_texcoord;\n}"},magnifier:{"magnifier.frag":"uniform lowp vec4 u_background;\nuniform mediump sampler2D u_readbackTexture;\nuniform mediump sampler2D u_maskTexture;\nuniform mediump sampler2D u_overlayTexture;\nuniform bool u_maskEnabled;\nuniform bool u_overlayEnabled;\nvarying mediump vec2 v_texCoord;\nconst lowp float barrelFactor = 1.1;\nlowp vec2 barrel(lowp vec2 uv) {\nlowp vec2 uvn = uv * 2.0 - 1.0;\nif (uvn.x == 0.0 && uvn.y == 0.0) {\nreturn vec2(0.5, 0.5);\n}\nlowp float theta = atan(uvn.y, uvn.x);\nlowp float r = pow(length(uvn), barrelFactor);\nreturn r * vec2(cos(theta), sin(theta)) * 0.5 + 0.5;\n}\nvoid main(void)\n{\nlowp vec4 color = texture2D(u_readbackTexture, barrel(v_texCoord));\ncolor = (color + (1.0 - color.a) * u_background);\nlowp float mask = u_maskEnabled ? texture2D(u_maskTexture, v_texCoord).a : 1.0;\ncolor *= mask;\nlowp vec4 overlayColor = u_overlayEnabled ? texture2D(u_overlayTexture, v_texCoord) : vec4(0);\ngl_FragColor = overlayColor + (1.0 - overlayColor.a) * color;\n}","magnifier.vert":"precision mediump float;\nattribute mediump vec2 a_pos;\nuniform mediump vec4 u_drawPos;\nvarying mediump vec2 v_texCoord;\nvoid main(void)\n{\nv_texCoord = a_pos;\ngl_Position = vec4(u_drawPos.xy + vec2(a_pos - 0.5) * u_drawPos.zw, 0.0, 1.0);\n}"},materials:{"attributeData.glsl":"uniform highp sampler2D u_attributeData0;\nuniform highp sampler2D u_attributeData1;\nuniform highp sampler2D u_attributeData2;\nuniform highp sampler2D u_attributeData3;\nuniform highp int u_attributeTextureSize;\nhighp vec2 getAttributeDataCoords(in highp vec4 id) {\nhighp vec4 texel = unpackDisplayIdTexel(id);\nhighp float size = float(u_attributeTextureSize);\nhighp float u32 = float(int(texel.r) + int(texel.g) * 256 + int(texel.b) * 256 * 256 + int(texel.a) * 256 * 256 * 256);\nhighp float col = mod(u32, size);\nhighp float row = (u32 - col) / size;\nhighp float u = col / size;\nhighp float v = row / size;\nreturn vec2(u, v);\n}\nhighp vec4 getAttributeData0(in highp vec4 id) {\nvec2 coords = getAttributeDataCoords(id);\nreturn texture2D(u_attributeData0, coords);\n}\nhighp vec4 getAttributeData1(in highp vec4 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(u_attributeData1, coords);\n}\nhighp vec4 getAttributeData2(in highp vec4 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(u_attributeData2, coords);\n}\nhighp vec4 getAttributeData3(in highp vec4 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(u_attributeData3, coords);\n}\nfloat u88VVToFloat(in vec2 v) {\nbool isMagic = v.x == 255.0 && v.y == 255.0;\nif (isMagic) {\nreturn NAN_MAGIC_NUMBER;\n}\nreturn (v.x + v.y * float(0x100)) - 32768.0;\n}","constants.glsl":"const float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float SIGNED_BYTE_TO_UNSIGNED = 128.0;\nconst float POSITION_PRECISION = 1.0 / 8.0;\nconst float FILL_POSITION_PRECISION = 1.0 / 1.0;\nconst float SOFT_EDGE_RATIO = 1.0;\nconst float THIN_LINE_WIDTH_FACTOR = 1.1;\nconst float THIN_LINE_HALF_WIDTH = 1.0;\nconst float EXTRUDE_SCALE_PLACEMENT_PADDING = 1.0 / 4.0;\nconst float OFFSET_PRECISION = 1.0 / 8.0;\nconst float OUTLINE_SCALE = 1.0 / 5.0;\nconst float SDF_FONT_SIZE = 24.0;\nconst float MAX_SDF_DISTANCE = 8.0;\nconst float PLACEMENT_PADDING = 8.0;\nconst float EPSILON = 0.0000001;\nconst int MAX_FILTER_COUNT = 2;\nconst int ATTR_VV_SIZE = 0;\nconst int ATTR_VV_COLOR = 1;\nconst int ATTR_VV_OPACITY = 2;\nconst int ATTR_VV_ROTATION = 3;\nconst highp float NAN_MAGIC_NUMBER = 1e-30;",fill:{"common.glsl":"#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\n#endif\n#ifdef DOT_DENSITY\nuniform lowp vec4 u_isActive[ 2 ];\nuniform highp float u_dotValue;\nuniform highp float u_tileDotsOverArea;\nuniform highp float u_dotTextureDotCount;\nuniform mediump float u_tileZoomFactor;\n#endif\nvarying vec3 v_pos;\nvarying lowp float v_opacity;\nvarying lowp vec4 v_color;\nvarying highp vec4 v_id;\nvarying highp float v_flags;\n#ifdef PATTERN\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif\n#ifdef DOT_DENSITY\nvarying highp vec2 v_dotTextureCoords;\nvarying highp vec4 v_dotThresholds[ 2 ];\n#endif","fill.frag":"precision highp float;\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/fill/common.glsl>\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\n#endif\n#ifdef DOT_DENSITY\nuniform mediump mat4 u_dotColors[ 2 ];\nuniform sampler2D u_dotTextures[ 2 ];\nuniform vec4 u_dotBackgroundColor;\n#endif\nvoid main() {\n#ifdef ID\ngl_FragColor = v_id;\n#elif defined(PATTERN)\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_opacity * v_color * color;\n#elif defined(DOT_DENSITY) && !defined(HIGHLIGHT)\nvec4 textureThresholds0 = texture2D(u_dotTextures[0], v_dotTextureCoords);\nvec4 textureThresholds1 = texture2D(u_dotTextures[1], v_dotTextureCoords);\nvec4 difference0 = v_dotThresholds[0] - textureThresholds0;\nvec4 difference1 = v_dotThresholds[1] - textureThresholds1;\n#ifdef DD_DOT_BLENDING\nvec4 isPositive0 = step(0.0, difference0);\nvec4 isPositive1 = step(0.0, difference1);\nfloat weightSum = dot(isPositive0, difference0) + dot(isPositive1, difference1);\nfloat lessThanEqZero = step(weightSum, 0.0);\nfloat greaterThanZero = 1.0 - lessThanEqZero ;\nfloat divisor = (weightSum + lessThanEqZero);\nvec4 weights0 = difference0 * isPositive0 / divisor;\nvec4 weights1 = difference1 * isPositive1 / divisor;\nvec4 dotColor = u_dotColors[0] * weights0 + u_dotColors[1] * weights1;\nvec4 preEffectColor = greaterThanZero * dotColor + lessThanEqZero * u_dotBackgroundColor;\n#else\nfloat diffMax = max(max4(difference0), max4(difference1));\nfloat lessThanZero = step(diffMax, 0.0);\nfloat greaterOrEqZero = 1.0 - lessThanZero;\nvec4 isMax0 = step(diffMax, difference0);\nvec4 isMax1 = step(diffMax, difference1);\nvec4 dotColor = u_dotColors[0] * isMax0 + u_dotColors[1] * isMax1;\nvec4 preEffectColor = greaterOrEqZero * dotColor + lessThanZero * u_dotBackgroundColor;\n#endif\ngl_FragColor = preEffectColor;\n#else\ngl_FragColor = v_opacity * v_color;\n#endif\n#ifdef HIGHLIGHT\ngl_FragColor.a = 1.0;\n#endif\n}","fill.vert":"precision highp float;\n#ifdef DOT_DENSITY\nattribute float a_inverseArea;\nvec4 a_color = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 a_aux3 = vec4(0.0);\nvec2 a_zoomRange = vec2(0.0, 10000.0);\n#else\nattribute vec4 a_color;\nattribute vec4 a_tlbr;\nattribute vec4 a_aux1;\nattribute vec2 a_aux2;\nattribute vec4 a_aux3;\nattribute vec2 a_zoomRange;\n#endif\n#include <materials/vcommon.glsl>\n#include <materials/fill/common.glsl>\n#ifdef DOT_DENSITY\nvec4 dotThreshold(vec4 featureAttrOverFeatureArea, float dotValue, float tileDotsOverArea) {\nreturn featureAttrOverFeatureArea * (1.0 / dotValue)  * (1.0 / tileDotsOverArea);\n}\n#endif\nvoid main()\n{\nINIT;\nfloat a_bitSet = a_aux3.a;\nv_color     = getColor(a_color, a_bitSet, 0);\nv_opacity   = getOpacity();\nv_id        = norm(a_id);\nv_pos       = u_dvsMat3 * vec3(a_pos * FILL_POSITION_PRECISION, 1.);\nv_flags     = getFilterFlags();\n#ifdef PATTERN\nvec2 aux2 = (1.0 / SIGNED_BYTE_TO_UNSIGNED) * a_aux2;\nfloat width = u_zoomFactor * a_aux1.x * aux2.x;\nfloat height = u_zoomFactor * a_aux1.y * aux2.y;\nfloat angle = C_256_TO_RAD * a_aux3.z;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nmat3 patternMatrix = mat3(cosA / width, sinA / height, 0,\n-sinA / width, cosA / height, 0,\n0,            0,             1);\nvec2 symbolOffset = (a_aux1.zw - SIGNED_BYTE_TO_UNSIGNED) / vec2(width, height);\nv_tileTextureCoord = (patternMatrix * vec3(a_pos * FILL_POSITION_PRECISION, 1.0)).xy - symbolOffset;\nv_tlbr = a_tlbr / u_mosaicSize.xyxy;\n#elif defined(DOT_DENSITY)\nvec4 ddAttributeData0 = getAttributeData2(a_id) * u_isActive[0] * a_inverseArea;\nvec4 ddAttributeData1 = getAttributeData3(a_id) * u_isActive[1] * a_inverseArea;\nfloat size = u_tileZoomFactor * 512.0 * 1.0 / u_pixelRatio;\nv_dotThresholds[0] = dotThreshold(ddAttributeData0, u_dotValue, u_tileDotsOverArea);\nv_dotThresholds[1] = dotThreshold(ddAttributeData1, u_dotValue, u_tileDotsOverArea);\nv_dotTextureCoords = (a_pos * FILL_POSITION_PRECISION + 0.5) / size;\n#endif\ngl_Position = vec4(clip(v_color, v_pos, v_flags, a_zoomRange), 1.0);\n}"},icon:{"common.glsl":"uniform lowp vec2 u_mosaicSize;\nvarying lowp vec4 v_color;\nvarying highp vec4 v_id;\nvarying highp vec4 v_sizeTex;\nvarying mediump vec3 v_pos;\nvarying highp float v_filters;\nvarying lowp float v_opacity;\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying mediump float v_distRatio;\nvarying mediump float v_overridingOutlineColor;\nvarying mediump float v_isThin;\n#endif","icon.frag":"precision mediump float;\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <util/encoding.glsl>\n#include <materials/constants.glsl>\n#include <materials/icon/common.glsl>\nuniform lowp sampler2D u_texture;\nvoid main()\n{\nvec2 v_size = v_sizeTex.xy;\nvec2 v_tex  = v_sizeTex.zw;\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * size * SOFT_EDGE_RATIO * v_distRatio;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nfloat outlineWidth = v_outlineWidth;\n#ifdef HIGHLIGHT\noutlineWidth = max(outlineWidth, 4.0 * v_isThin);\n#endif\nif (outlineWidth > 0.25) {\nlowp vec4 outlinePixelColor = v_overridingOutlineColor * v_color + (1.0 - v_overridingOutlineColor) * v_outlineColor;\nfloat clampedOutlineSize = min(outlineWidth, size);\noutlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\ngl_FragColor = v_opacity * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef HIGHLIGHT\ngl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"precision highp float;\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nattribute vec2 a_bitSetAndDistRatio;\nattribute vec2 a_zoomRange;\n#include <materials/vcommon.glsl>\n#include <materials/icon/common.glsl>\nvec2 getMarkerSize(inout vec2 offset, inout vec2 baseSize, inout float outlineSize, in float referenceSize, in float bitSet) {\n#ifdef VV_SIZE\nfloat r = getSize(baseSize.y) / referenceSize;\nbaseSize.xy *= r;\noffset.xy *= r;\nfloat scaleSymbolProportionally = getBit(bitSet, 3);\noutlineSize *= scaleSymbolProportionally * (r - 1.0) + 1.0;\n#endif\nreturn baseSize;\n}\nvec3 getOffset(in vec2 in_offset, float a_bitSet) {\nfloat isMapAligned = getBit(a_bitSet, 0);\nvec3  offset       = getRotation() * vec3(in_offset, 0.0);\nreturn getMatrix(isMapAligned) * offset;\n}\nvoid main()\n{\nINIT;\nvec2  a_size   = a_sizeAndOutlineWidth.xy * a_sizeAndOutlineWidth.xy / 128.0;\nvec2  a_offset = a_vertexOffset / 16.0;\nfloat a_outlineSize = a_sizeAndOutlineWidth.z * a_sizeAndOutlineWidth.z / 128.0;\nfloat a_bitSet = a_bitSetAndDistRatio.x;\nvec2 v_size = getMarkerSize(a_offset, a_size, a_outlineSize, a_sizeAndOutlineWidth.w * a_sizeAndOutlineWidth.w / 128.0, a_bitSet);\nvec2 v_tex      = a_texCoords / u_mosaicSize;\nv_color    = getColor(a_color, a_bitSet, 1);\nv_opacity  = getOpacity();\nv_id       = norm(a_id);\nv_filters  = getFilterFlags();\nv_pos      = u_dvsMat3 * vec3(a_pos * POSITION_PRECISION, 1.0) + getOffset(a_offset, a_bitSet);\nv_sizeTex  = vec4(v_size.xy, v_tex.xy);\n#ifdef SDF\nv_isThin   = getBit(a_bitSet, 2);\n#ifdef VV_COLOR\nv_overridingOutlineColor = v_isThin;\n#else\nv_overridingOutlineColor = 0.0;\n#endif\nv_outlineWidth = min(a_outlineSize, max(max(v_size.x, v_size.y) - 0.99, 0.0));\nv_outlineColor = a_outlineColor;\nv_distRatio = a_bitSetAndDistRatio.y / 126.0;\n#endif\ngl_Position = vec4(clip(v_color, v_pos, v_filters, a_zoomRange), 1.0);\n}"},label:{"common.glsl":"uniform mediump float u_zoomLevel;\nuniform mediump float u_mapRotation;\nuniform mediump float u_mapAligned;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying mediump vec4 v_color;\nvarying lowp vec4 v_animation;","label.frag":"#include <materials/text/text.frag>","label.vert":"precision highp float;\n#include <materials/vcommon.glsl>\n#include <materials/text/common.glsl>\nattribute vec4 a_color;\nattribute vec4 a_haloColor;\nattribute vec4 a_texAndSize;\nattribute vec4 a_refSymbolAndPlacementOffset;\nattribute vec4 a_glyphData;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nuniform float u_isHalo;\nuniform float u_mapRotation;\nuniform float u_mapAligned;\nfloat getZ(in float minZoom, in float maxZoom, in float angle) {\nfloat glyphAngle = angle * 360.0 / 254.0;\nfloat mapAngle = u_mapRotation * 360.0 / 254.0;\nfloat diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\nfloat z = 0.0;\nz += u_mapAligned * (2.0 * (1.0 - step(minZoom, u_currentZoom)));\nz += u_mapAligned * 2.0 * step(90.0, diffAngle);\nz += 2.0 * (1.0 - step(u_currentZoom, maxZoom));\nreturn z;\n}\nvoid main()\n{\nINIT;\nfloat groupMinZoom    = getMinZoom();\nfloat glyphMinZoom    = a_glyphData.x;\nfloat glyphMaxZoom    = a_glyphData.y;\nfloat glyphAngle      = a_glyphData.z;\nfloat a_minZoom          = max(groupMinZoom, glyphMinZoom);\nfloat a_placementPadding = a_refSymbolAndPlacementOffset.x * EXTRUDE_SCALE_PLACEMENT_PADDING;\nvec2  a_placementDir     = unpack_u8_nf32(a_refSymbolAndPlacementOffset.zw);\nfloat a_refSymbolSize    = a_refSymbolAndPlacementOffset.y;\nfloat fontSize           = a_texAndSize.z;\nfloat haloSize           = a_texAndSize.w * OUTLINE_SCALE;\nvec2  vertexOffset = a_vertexOffset * OFFSET_PRECISION;\nvec3  pos          = vec3(a_pos * POSITION_PRECISION, 1.0);\nfloat z            = getZ(a_minZoom, glyphMaxZoom, glyphAngle);\nfloat fontScale    = fontSize / SDF_FONT_SIZE;\nfloat halfSize     = getSize(a_refSymbolSize) / 2.0;\nfloat animation    = pow(getAnimationState(), vec4(2.0)).r;\nv_color     = animation * ((1.0 - u_isHalo) * a_color + (u_isHalo * a_haloColor));\nv_opacity   = 1.0;\nv_tex       = a_texCoords / u_mosaicSize;\nv_edgeDistanceOffset = u_isHalo * haloSize / fontScale / MAX_SDF_DISTANCE;\nv_antialiasingWidth  = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\nvec2 placementOffset = a_placementDir * (halfSize + a_placementPadding);\nvec3 glyphOffset     = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\nvec3 v_pos           = vec3((u_dvsMat3 * pos + glyphOffset).xy, z);\ngl_Position = vec4(applyFilterLabels(v_color, v_pos, getFilterFlags()), 1.0);\n#ifdef DEBUG\nv_color = vec4(a_color.rgb, z == 0.0 ? 1.0 : 0.645);\n#endif\n}"},line:{"common.glsl":"varying lowp vec4 v_color;\nvarying highp vec4 v_id;\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp float v_opacity;\nvarying highp vec3 v_pos;\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\n#endif\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance;\n#endif","line.frag":"precision lowp float;\n#include <util/encoding.glsl>\n#include <materials/constants.glsl>\n#include <materials/line/common.glsl>\nuniform lowp float u_blur;\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\n#endif\n#ifdef SDF\nconst float sdfPatternHalfWidth = 15.5;\nuniform mediump float u_antialiasing;\n#endif\nvoid main()\n{\nmediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\n#if defined(SDF) && !defined(HIGHLIGHT)\nmediump float lineHalfWidth = v_lineHalfWidth;\nmediump float lineWidthRatio = max(lineHalfWidth - 0.55 * u_antialiasing, 0.25) / sdfPatternHalfWidth;\nmediump float relativeTexX = mod(v_accumulatedDistance * 0.5 / (lineWidthRatio * v_patternSize.x), 1.0);\nmediump float relativeTexY = 0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * lineHalfWidth;\nlowp vec4 fillPixelColor = v_opacity * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\ngl_FragColor = fillPixelColor;\n#elif defined(PATTERN) && !defined(HIGHLIGHT)\nmediump float lineHalfWidth = v_lineHalfWidth;\nmediump float adjustedPatternWidth = v_patternSize.x * 2.0 * lineHalfWidth / v_patternSize.y;\nmediump float relativeTexX = mod(v_accumulatedDistance / adjustedPatternWidth, 1.0);\nmediump float relativeTexY = 0.5 + 0.5 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexY, relativeTexX));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = v_opacity * alpha * v_color * color;\n#else\ngl_FragColor = v_opacity * alpha * v_color;\n#endif\n#ifdef HIGHLIGHT\ngl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision highp float;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\nattribute vec2 a_aux;\nattribute vec2 a_zoomRange;\n#include <materials/vcommon.glsl>\n#include <materials/line/common.glsl>\nconst float SCALE = 1.0 / 31.0;\nconst float WIDTH_SCALE = 1.0 / 1024.0;\nfloat getBaseLineHalfWidth(in float in_lineHalfWidth) {\n#ifdef VV_SIZE\nfloat referenceHalfWidth = a_aux.x * WIDTH_SCALE;\nfloat lineWidth = 2.0 * in_lineHalfWidth;\nreturn 0.5 * (in_lineHalfWidth / referenceHalfWidth) * getSize(lineWidth);\n#else\nreturn in_lineHalfWidth;\n#endif\n}\nfloat getLineHalfWidth(in float baseWidth, in float aa) {\nfloat halfWidth = max(baseWidth + aa, 0.45) + 0.1 * aa;\n#ifdef HIGHLIGHT\nhalfWidth = max(halfWidth, 2.0);\n#endif\nreturn halfWidth;\n}\nvec2 getDist(in vec2 offset, in float halfWidth) {\nfloat thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(halfWidth, THIN_LINE_HALF_WIDTH), 1.0);\nreturn thinLineFactor * halfWidth * offset * SCALE;\n}\nvoid main()\n{\nINIT;\nfloat a_bitSet          = a_segmentDirection.w;\nfloat a_accumulatedDist = a_accumulatedDistanceAndHalfWidth.x;\nfloat a_lineHalfWidth   = a_accumulatedDistanceAndHalfWidth.y * WIDTH_SCALE;\nfloat aa                = 0.5 * u_antialiasing;\nvec2  a_offset          = a_offsetAndNormal.xy;\nfloat baseWidth = getBaseLineHalfWidth(a_lineHalfWidth);\nfloat halfWidth = getLineHalfWidth(baseWidth, aa);\nfloat z         = 2.0 * step(baseWidth, 0.0);\nvec2  dist      = getDist(a_offset, halfWidth);\nvec3  offset    = u_displayViewMat3 * vec3(dist, 0.0);\nvec3  pos       = u_dvsMat3 * vec3(a_pos * POSITION_PRECISION, 1.0) + offset;\nv_color         = getColor(a_color, a_bitSet, 0);\nv_opacity       = getOpacity();\nv_lineHalfWidth = halfWidth;\nv_id            = norm(a_id);\nv_normal        = a_offsetAndNormal.zw * SCALE;\nv_pos           = vec3(pos.xy, z);\n#ifdef PATTERN\nv_tlbr          = a_tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\n#endif\n#if defined(PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDist * u_zoomFactor + dot(SCALE * a_segmentDirection.xy, dist);\n#endif\ngl_Position = vec4(clip(v_color, v_pos, getFilterFlags(), a_zoomRange), 1.0);\n}"},text:{"common.glsl":"uniform highp vec2 u_mosaicSize;\nvarying highp vec4 v_id;\nvarying mediump vec3 v_pos;\nvarying lowp float v_opacity;\nvarying lowp vec4 v_color;\nvarying highp vec2 v_tex;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying lowp float v_transparency;","text.frag":"precision mediump float;\n#include <materials/text/common.glsl>\nuniform lowp sampler2D u_texture;\nvoid main()\n{\nfloat SDF_CUTOFF = (2.0 / 8.0);\nfloat SDF_BASE_EDGE_DIST = 1.0 - SDF_CUTOFF;\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float edge = SDF_BASE_EDGE_DIST - v_edgeDistanceOffset;\n#ifdef HIGHLIGHT\nedge /= 2.0;\n#endif\nlowp float aa = v_antialiasingWidth;\nlowp float alpha = smoothstep(edge - aa, edge + aa, dist);\ngl_FragColor = alpha * v_color * v_opacity;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"precision highp float;\n#include <materials/utils.glsl>\n#include <materials/vcommon.glsl>\n#include <materials/text/common.glsl>\nattribute vec4 a_color;\nattribute vec4 a_haloColor;\nattribute vec4 a_texFontSize;\nattribute vec4 a_aux;\nattribute vec2 a_zoomRange;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nuniform float u_isHalo;\nfloat getTextSize(in float baseSize, in float referenceSize) {\n#ifdef VV_SIZE\nreturn getSize(baseSize);\n#endif\nreturn baseSize;\n}\nvoid main()\n{\nINIT;\nfloat a_referenceSize = a_aux.z * a_aux.z / 256.0;\nfloat a_bitSet        = a_aux.w;\nfloat a_fontSize      = a_texFontSize.z;\nvec2  a_offset        = a_vertexOffset * OFFSET_PRECISION;\nvec3  in_pos        = vec3(a_pos * POSITION_PRECISION, 1.0);\nfloat fontSize      = getTextSize(a_fontSize, a_referenceSize);\nfloat scaleFactor   = fontSize / a_fontSize;\nfloat fontScale     = fontSize / SDF_FONT_SIZE;\nvec3  offset        = getRotation() * vec3(scaleFactor * a_offset, 0.0);\nmat3  extrudeMatrix = getBit(a_bitSet, 0) == 1.0 ? u_displayViewMat3 : u_displayMat3;\nv_color   = u_isHalo * a_haloColor + (1.0 - u_isHalo) * getColor(a_color, a_bitSet, 1);\nv_opacity = getOpacity();\nv_id      = norm(a_id);\nv_tex     = a_texCoords / u_mosaicSize;\nv_pos     = u_dvsMat3 * in_pos + extrudeMatrix * offset;\nv_edgeDistanceOffset = u_isHalo * OUTLINE_SCALE * a_texFontSize.w / fontScale / MAX_SDF_DISTANCE;\nv_antialiasingWidth  = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\ngl_Position =  vec4(clip(v_color, v_pos, getFilterFlags(), a_zoomRange), 1.0);\n}"},"utils.glsl":"float rshift(in float u32, in int amount) {\nreturn floor(u32 / pow(2.0, float(amount)));\n}\nfloat getBit(in float bitset, in int bitIndex) {\nfloat offset = pow(2.0, float(bitIndex));\nreturn mod(floor(bitset / offset), 2.0);\n}\nfloat getFilterBit(in float bitset, in int bitIndex) {\nreturn getBit(bitset, bitIndex + 1);\n}\nfloat getHighlightBit(in float bitset) {\nreturn getBit(bitset, 0);\n}\nhighp vec4 unpackDisplayIdTexel(in highp vec4 bitset) {\nfloat isAggregate = getBit(bitset.a, 7);\nreturn (1.0 - isAggregate) * bitset + isAggregate * (vec4(bitset.rgba) - vec4(0.0, 0.0, 0.0, float(0x80)));\n}\nvec4 unpack(in float u32) {\nfloat r = mod(rshift(u32, 0), 255.0);\nfloat g = mod(rshift(u32, 8), 255.0);\nfloat b = mod(rshift(u32, 16), 255.0);\nfloat a = mod(rshift(u32, 24), 255.0);\nreturn vec4(r, g, b, a);\n}\nvec4 norm(in vec4 v) {\nreturn v /= 255.0;\n}\nfloat max4(vec4 target) {\nreturn max(max(max(target.x, target.y), target.z), target.w);\n}\nvec2 unpack_u8_nf32(vec2 bytes) {\nreturn (bytes - 127.0) / 127.0;\n}","vcommon.glsl":"#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/attributeData.glsl>\n#include <materials/vv.glsl>\nattribute vec2 a_pos;\nattribute highp vec4 a_id;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform highp float u_pixelRatio;\nuniform mediump float u_zoomFactor;\nuniform mediump float u_antialiasing;\nuniform mediump float u_currentZoom;\nvec4 VV_ADATA = vec4(0.0);\nvoid loadVisualVariableData(inout vec4 target) {\n#ifdef OES_TEXTURE_FLOAT\ntarget.rgba = getAttributeData2(a_id);\n#else\nvec4 data0 = getAttributeData2(a_id);\nvec4 data1 = getAttributeData3(a_id);\ntarget.r = u88VVToFloat(data0.rg * 255.0);\ntarget.g = u88VVToFloat(data0.ba * 255.0);\ntarget.b = u88VVToFloat(data1.rg * 255.0);\ntarget.a = u88VVToFloat(data1.ba * 255.0);\n#endif\n}\n#ifdef VV\n#define INIT loadVisualVariableData(VV_ADATA)\n#else\n#define INIT\n#endif\nvec4 getColor(in vec4 a_color, in float a_bitSet, int index) {\n#ifdef VV_COLOR\nfloat isColorLocked   = getBit(a_bitSet, index);\nreturn getVVColor(VV_ADATA[ATTR_VV_COLOR], a_color, isColorLocked);\n#else\nreturn a_color;\n#endif\n}\nfloat getOpacity() {\n#ifdef VV_OPACITY\nreturn getVVOpacity(VV_ADATA[ATTR_VV_OPACITY]);\n#else\nreturn 1.0;\n#endif\n}\nfloat getSize(in float in_size) {\n#ifdef VV_SIZE\nreturn getVVSize(in_size, VV_ADATA[ATTR_VV_SIZE]);\n#else\nreturn in_size;\n#endif\n}\nmat3 getRotation() {\n#ifdef VV_ROTATION\nreturn getVVRotationMat3(mod(VV_ADATA[ATTR_VV_ROTATION], 360.0));\n#else\nreturn mat3(1.0);\n#endif\n}\nfloat getFilterFlags() {\n#ifdef IGNORES_SAMPLER_PRECISION\nreturn ceil(getAttributeData0(a_id).x * 255.0);\n#else\nreturn getAttributeData0(a_id).x * 255.0;\n#endif\n}\nvec4 getAnimationState() {\nreturn getAttributeData1(a_id);\n}\nfloat getMinZoom() {\nvec4 data0 = getAttributeData0(a_id) * 255.0;\nreturn data0.g;\n}\nmat3 getMatrix(float isMapAligned) {\nreturn isMapAligned * u_displayViewMat3 + (1.0 - isMapAligned) * u_displayMat3;\n}\nvec3 clip(inout vec4 color, inout vec3 pos, in float filterFlags, in vec2 minMaxZoom) {\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 0));\n#ifdef INSIDE\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 1));\n#elif defined(OUTSIDE)\npos.z += 2.0 * getFilterBit(filterFlags, 1);\n#elif defined(HIGHLIGHT)\n#if !defined(HIGHLIGHT_ALL)\npos.z += 2.0 * (1.0 - getHighlightBit(filterFlags));\n#endif\n#endif\npos.z += 2.0 * (step(minMaxZoom.y, u_currentZoom) + (1.0 - step(minMaxZoom.x, u_currentZoom)));\nreturn pos;\n}\nvec3 applyFilterLabels(inout vec4 color, inout vec3 pos, in float filterFlags) {\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 0));\n#ifndef OUTSIDE_LABELS_VISIBLE\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 1));\n#endif\nreturn pos;\n}","vv.glsl":"#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n#define VV_SIZE\n#endif\n#if defined(VV_COLOR) || defined(VV_SIZE) || defined(VV_OPACITY) || defined(VV_ROTATION)\n#define VV\n#endif\n#ifdef VV_COLOR\nuniform highp float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 u_vvSizeMinMaxValue;\n#endif\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float u_vvSizeScaleStopsValue;\n#endif\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif\n#ifdef VV_SIZE_UNIT_VALUE\nuniform highp float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif\n#ifdef VV_OPACITY\nuniform highp float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif\nbool isNan(float val) {\nreturn (val == NAN_MAGIC_NUMBER);\n}\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nfloat interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\ninterpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\nreturn u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\n}\n#endif\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nif (sizeValue <= u_vvSizeFieldStopsValues[0]) {\nreturn u_vvSizeFieldStopsSizes[0];\n}\nfor (int i = 1; i < VV_SIZE_N; ++i) {\nif (u_vvSizeFieldStopsValues[i] >= sizeValue) {\nfloat f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\nreturn mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n}\n}\nreturn u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nreturn u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\nif (isNan(opacityValue)) {\nreturn 1.0;\n}\nif (opacityValue <= u_vvOpacityValues[0]) {\nreturn u_vvOpacities[0];\n}\nfor (int i = 1; i < VV_OPACITY_N; ++i) {\nif (u_vvOpacityValues[i] >= opacityValue) {\nfloat f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\nreturn mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n}\n}\nreturn u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\nif (isNan(rotationValue)) {\nreturn mat4(1, 0, 0, 0,\n0, 1, 0, 0,\n0, 0, 1, 0,\n0, 0, 0, 1);\n}\nfloat rotation = rotationValue;\nif (u_vvRotationType == 1.0) {\nrotation = 90.0 - rotation;\n}\nfloat angle = C_DEG_TO_RAD * rotation;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nreturn mat4(cosA, sinA, 0, 0,\n-sinA,  cosA, 0, 0,\n0,     0, 1, 0,\n0,     0, 0, 1);\n}\nmat3 getVVRotationMat3(float rotationValue) {\nif (isNan(rotationValue)) {\nreturn mat3(1, 0, 0,\n0, 1, 0,\n0, 0, 1);\n}\nfloat rotation = rotationValue;\nif (u_vvRotationType == 1.0) {\nrotation = 90.0 - rotation;\n}\nfloat angle = C_DEG_TO_RAD * -rotation;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nreturn mat3(cosA, -sinA, 0,\nsinA, cosA, 0,\n0,    0,    1);\n}\n#endif\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\nvec4 getVVColor(float colorValue, vec4 fallback, float isColorLocked) {\nif (isNan(colorValue) || isColorLocked == 1.0) {\nreturn fallback;\n}\nif (colorValue <= u_vvColorValues[0]) {\nreturn u_vvColors[0];\n}\nfor (int i = 1; i < VV_COLOR_N; ++i) {\nif (u_vvColorValues[i] >= colorValue) {\nfloat f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\nreturn mix(u_vvColors[i-1], u_vvColors[i], f);\n}\n}\nreturn u_vvColors[VV_COLOR_N - 1];\n}\n#endif\nfloat getVVSize(in float size, in float vvSize)  {\n#ifdef VV_SIZE_MIN_MAX_VALUE\nreturn getVVMinMaxSize(vvSize, size);\n#elif defined(VV_SIZE_SCALE_STOPS)\nreturn u_vvSizeScaleStopsValue;\n#elif defined(VV_SIZE_FIELD_STOPS)\nfloat outSize = getVVStopsSize(vvSize, size);\nreturn isNan(outSize) ? size : outSize;\n#elif defined(VV_SIZE_UNIT_VALUE)\nreturn getVVUnitValue(vvSize, size);\n#else\nreturn size;\n#endif\n}"},"post-processing":{blit:{"blit.frag":"precision mediump float;\nuniform sampler2D u_texture;\nvarying vec2 v_uv;\nvoid main() {\ngl_FragColor = texture2D(u_texture, v_uv);\n}"},bloom:{composite:{"composite.frag":"precision mediump float;\nvarying vec2 v_uv;\nuniform sampler2D u_blurTexture1;\nuniform sampler2D u_blurTexture2;\nuniform sampler2D u_blurTexture3;\nuniform sampler2D u_blurTexture4;\nuniform sampler2D u_blurTexture5;\nuniform float u_bloomStrength;\nuniform float u_bloomRadius;\nuniform float u_bloomFactors[NUMMIPS];\nuniform vec3 u_bloomTintColors[NUMMIPS];\nfloat lerpBloomFactor(const in float factor) {\nfloat mirrorFactor = 1.2 - factor;\nreturn mix(factor, mirrorFactor, u_bloomRadius);\n}\nvoid main() {\ngl_FragColor = u_bloomStrength * (\nlerpBloomFactor(u_bloomFactors[0]) * vec4(u_bloomTintColors[0], 1.0) * texture2D(u_blurTexture1, v_uv) +\nlerpBloomFactor(u_bloomFactors[1]) * vec4(u_bloomTintColors[1], 1.0) * texture2D(u_blurTexture2, v_uv) +\nlerpBloomFactor(u_bloomFactors[2]) * vec4(u_bloomTintColors[2], 1.0) * texture2D(u_blurTexture3, v_uv) +\nlerpBloomFactor(u_bloomFactors[3]) * vec4(u_bloomTintColors[3], 1.0) * texture2D(u_blurTexture4, v_uv) +\nlerpBloomFactor(u_bloomFactors[4]) * vec4(u_bloomTintColors[4], 1.0) * texture2D(u_blurTexture5, v_uv)\n);\n}"},gaussianBlur:{"gaussianBlur.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_texSize;\nuniform vec2 u_direction;\nvarying vec2 v_uv;\n#define KERNEL_RADIUS RADIUS\n#define SIGMA RADIUS\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x / ( sigma * sigma)) / sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / u_texSize;\nfloat fSigma = float(SIGMA);\nfloat weightSum = gaussianPdf(0.0, fSigma);\nvec4 pixelColorSum = texture2D(u_colorTexture, v_uv) * weightSum;\nfor (int i = 1; i < KERNEL_RADIUS; i ++) {\nfloat x = float(i);\nfloat w = gaussianPdf(x, fSigma);\nvec2 uvOffset = u_direction * invSize * x;\nvec4 sample1 = texture2D(u_colorTexture, v_uv + uvOffset);\nvec4 sample2 = texture2D(u_colorTexture, v_uv - uvOffset);\npixelColorSum += (sample1 + sample2) * w;\nweightSum += 2.0 * w;\n}\ngl_FragColor = pixelColorSum /weightSum;\n}"},luminosityHighPass:{"luminosityHighPass.frag":"precision mediump float;\nuniform sampler2D u_texture;\nuniform vec3 u_defaultColor;\nuniform float u_defaultOpacity;\nuniform float u_luminosityThreshold;\nuniform float u_smoothWidth;\nvarying vec2 v_uv;\nvoid main() {\nvec4 texel = texture2D(u_texture, v_uv);\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat v = dot(texel.xyz, luma);\nvec4 outputColor = vec4(u_defaultColor.rgb, u_defaultOpacity);\nfloat alpha = smoothstep(u_luminosityThreshold, u_luminosityThreshold + u_smoothWidth, v);\ngl_FragColor = mix(outputColor, texel, alpha);\n}"}},blur:{gaussianBlur:{"gaussianBlur.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_texSize;\nuniform vec2 u_direction;\nuniform float u_sigma;\nvarying vec2 v_uv;\n#define KERNEL_RADIUS RADIUS\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x / ( sigma * sigma)) / sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / u_texSize;\nfloat fSigma = u_sigma;\nfloat weightSum = gaussianPdf(0.0, fSigma);\nvec4 pixelColorSum = texture2D(u_colorTexture, v_uv) * weightSum;\nfor (int i = 1; i < KERNEL_RADIUS; i ++) {\nfloat x = float(i);\nfloat w = gaussianPdf(x, fSigma);\nvec2 uvOffset = u_direction * invSize * x;\nvec4 sample1 = texture2D(u_colorTexture, v_uv + uvOffset);\nvec4 sample2 = texture2D(u_colorTexture, v_uv - uvOffset);\npixelColorSum += (sample1 + sample2) * w;\nweightSum += 2.0 * w;\n}\ngl_FragColor = pixelColorSum /weightSum;\n}"},"radial-blur":{"radial-blur.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nvarying vec2 v_uv;\nconst float sampleDist = 1.0;\nconst float sampleStrength = 2.2;\nvoid main(void) {\nfloat samples[10];\nsamples[0] = -0.08;\nsamples[1] = -0.05;\nsamples[2] = -0.03;\nsamples[3] = -0.02;\nsamples[4] = -0.01;\nsamples[5] =  0.01;\nsamples[6] =  0.02;\nsamples[7] =  0.03;\nsamples[8] =  0.05;\nsamples[9] =  0.08;\nvec2 dir = 0.5 - v_uv;\nfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\ndir = dir / dist;\nvec4 color = texture2D(u_colorTexture,v_uv);\nvec4 sum = color;\nfor (int i = 0; i < 10; i++) {\nsum += texture2D(u_colorTexture, v_uv + dir * samples[i] * sampleDist);\n}\nsum *= 1.0 / 11.0;\nfloat t = dist * sampleStrength;\nt = clamp(t, 0.0, 1.0);\ngl_FragColor = mix(color, sum, t);\n}"}},dra:{"dra.frag":"precision mediump float;\nuniform sampler2D u_minColor;\nuniform sampler2D u_maxColor;\nuniform sampler2D u_texture;\nvarying vec2 v_uv;\nvoid main() {\nvec4 minColor = texture2D(u_minColor, vec2(0.5));\nvec4 maxColor = texture2D(u_maxColor, vec2(0.5));\nvec4 color = texture2D(u_texture, v_uv);\nvec3 minColorUnpremultiply = minColor.rgb / minColor.a;\nvec3 maxColorUnpremultiply = maxColor.rgb / maxColor.a;\nvec3 colorUnpremultiply = color.rgb / color.a;\nvec3 range = maxColorUnpremultiply - minColorUnpremultiply;\ngl_FragColor = vec4(color.a * (colorUnpremultiply - minColorUnpremultiply) / range, color.a);\n}","min-max":{"min-max.frag":"#extension GL_EXT_draw_buffers : require\nprecision mediump float;\n#define CELL_SIZE 2\nuniform sampler2D u_minTexture;\nuniform sampler2D u_maxTexture;\nuniform vec2 u_srcResolution;\nuniform vec2 u_dstResolution;\nvarying vec2 v_uv;\nvoid main() {\nvec2 srcPixel = floor(gl_FragCoord.xy) * float(CELL_SIZE);\nvec2 onePixel = vec2(1.0) / u_srcResolution;\nvec2 uv = (srcPixel + 0.5) / u_srcResolution;\nvec4 minColor = vec4(1.0);\nvec4 maxColor = vec4(0.0);\nfor (int y = 0; y < CELL_SIZE; ++y) {\nfor (int x = 0; x < CELL_SIZE; ++x) {\nvec2 offset = uv + vec2(x, y) * onePixel;\nminColor = min(minColor, texture2D(u_minTexture, offset));\nmaxColor = max(maxColor, texture2D(u_maxTexture, offset));\n}\n}\ngl_FragData[0] = minColor;\ngl_FragData[1] = maxColor;\n}"}},"drop-shadow":{composite:{"composite.frag":"precision mediump float;\nuniform sampler2D u_layerFBOTexture;\nuniform sampler2D u_blurTexture;\nuniform vec4 u_shadowColor;\nvarying vec2 v_uv;\nvoid main() {\nvec4 layerColor = texture2D(u_layerFBOTexture, v_uv);\nvec4 blurColor = texture2D(u_blurTexture, v_uv);\ngl_FragColor = ((1.0 - layerColor.a) * blurColor.a * u_shadowColor + layerColor);\n}"},"drop-shadow.vert":"precision mediump float;\nattribute vec2 a_position;\nuniform highp mat3 u_displayViewMat3;\nuniform highp vec2 u_offset;\nvarying vec2 v_uv;\nvoid main() {\nvec3 offset = u_displayViewMat3 * vec3(u_offset, 0.0);\ngl_Position = vec4(a_position, 0.0, 1.0) + vec4(offset, 0.0);\nv_uv = (a_position + 1.0) / 2.0;\n}"},"edge-detect":{"frei-chen":{"frei-chen.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_texSize;\nvarying vec2 v_uv;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[9];\nconst mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\nconst mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\nconst mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\nconst mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\nconst mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\nconst mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\nconst mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\nconst mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\nconst mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\nvoid main() {\nG[0] = g0,\nG[1] = g1,\nG[2] = g2,\nG[3] = g3,\nG[4] = g4,\nG[5] = g5,\nG[6] = g6,\nG[7] = g7,\nG[8] = g8;\nmat3 I;\nfloat cnv[9];\nvec3 sample;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D(u_colorTexture, v_uv + texel * vec2(i - 1.0,j - 1.0)).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 9; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\nfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\nfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\ngl_FragColor = vec4(vec3(sqrt(M / S)), texture2D(u_colorTexture, v_uv).a);\n}"},sobel:{"sobel.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nvarying vec2 v_uv;\nuniform vec2 u_texSize;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[2];\nconst mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\nconst mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\nvoid main() {\nmat3 I;\nfloat cnv[2];\nvec3 sample;\nG[0] = g0;\nG[1] = g1;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D( u_colorTexture, v_uv + texel * vec2(i-1.0,j-1.0) ).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 2; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\ngl_FragColor = vec4(vec3(0.5 * sqrt(cnv[0] * cnv[0] + cnv[1] * cnv[1])), texture2D(u_colorTexture, v_uv).a);\n}"}},"edge-enhance":{"edge-enhance.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nvarying vec2 v_uv;\nuniform vec2 u_texSize;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[2];\nconst mat3 g0 = mat3( 1.0, 0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0 );\nconst mat3 g1 = mat3( 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, -1.0, -1.0, -1.0 );\nvoid main() {\nmat3 I;\nfloat cnv[2];\nvec3 sample;\nG[0] = g0;\nG[1] = g1;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D( u_colorTexture, v_uv + texel * vec2(i-1.0,j-1.0) ).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 2; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\nvec4 color = texture2D(u_colorTexture, v_uv);\ngl_FragColor = vec4(0.5 * sqrt(cnv[0] * cnv[0] + cnv[1] * cnv[1]) * color);\n}"},filterEffect:{"filterEffect.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform mat4 u_coefficients;\nvarying vec2 v_uv;\nvoid main() {\nvec4 color = texture2D(u_colorTexture, v_uv);\nvec4 rgbw = u_coefficients * vec4(color.a > 0.0 ? color.rgb / color.a : vec3(0.0), 1.0);\nfloat a = color.a;\ngl_FragColor = vec4(a * rgbw.rgb, a);\n}"},pp:{"pp.vert":"precision mediump float;\nattribute vec2 a_position;\nvarying vec2 v_uv;\nvoid main() {\ngl_Position = vec4(a_position, 0.0, 1.0);\nv_uv = (a_position + 1.0) / 2.0;\n}"}},raster:{bitmap:{"bitmap.frag":"precision mediump float;\nvarying highp vec2 v_texcoord;\nuniform sampler2D u_texture;\nuniform highp vec2 u_coordScale;\nuniform lowp float u_opacity;\n#include <filtering/bicubic.glsl>\nvoid main() {\n#ifdef BICUBIC\nvec4 color = sampleBicubicBSpline(u_texture, v_texcoord, u_coordScale);\n#else\nvec4 color = texture2D(u_texture, v_texcoord);\n#endif\nfloat alpha = u_opacity * color.a;\ngl_FragColor = vec4(alpha * color.rgb, alpha);\n}","bitmap.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform highp vec2 u_coordScale;\nvarying highp vec2 v_texcoord;\nvoid main()\n{\nv_texcoord = a_pos;\ngl_Position = vec4(u_dvsMat3 * vec3(a_pos * u_coordScale, 1.0), 1.0);\n}"},common:{"common.glsl":"uniform sampler2D u_image;\nuniform int u_bandCount;\nuniform bool u_isFloatTexture;\nuniform bool u_flipY;\nuniform float u_opacity;\nuniform int u_resampling;\nuniform vec2 u_srcImageSize;\n#ifdef APPLY_PROJECTION\n#include <raster/common/projection.glsl>\n#endif\n#ifdef BICUBIC\n#include <filtering/bicubic.glsl>\n#endif\n#ifdef BILINEAR\n#include <filtering/bilinear.glsl>\n#endif\nvec2 getPixelLocation(vec2 coords) {\nvec2 targetLocation = u_flipY ? vec2(coords.s, 1.0 - coords.t) : coords;\n#ifdef APPLY_PROJECTION\ntargetLocation = projectPixelLocation(targetLocation);\n#endif\nreturn targetLocation;\n}\nbool isOutside(vec2 coords){\nif (coords.t>1.00001 ||coords.t<-0.00001 || coords.s>1.00001 ||coords.s<-0.00001) {\nreturn true;\n} else {\nreturn false;\n}\n}\nvec4 getPixel(vec2 pixelLocation) {\n#ifdef BICUBIC\nvec4 color = sampleBicubicBSpline(u_image, pixelLocation, u_srcImageSize);\n#elif defined(BILINEAR)\nvec4 color = sampleBilinear(u_image, pixelLocation, u_srcImageSize);\n#else\nvec4 color = texture2D(u_image, pixelLocation);\n#endif\nreturn color;\n}","contrastBrightness.glsl":"uniform float u_contrastOffset;\nuniform float u_brightnessOffset;\nvec4 adjustContrastBrightness(vec4 currentPixel, bool isFloat) {\nvec4 pixelValue = isFloat ? currentPixel * 255.0 : currentPixel;\nfloat maxI = 255.0;\nfloat mid = 128.0;\nfloat c = u_contrastOffset;\nfloat b = u_brightnessOffset;\nvec4 v;\nif (c > 0.0 && c < 100.0) {\nv = (200.0 * pixelValue - 100.0 * maxI + 2.0 * maxI * b) / (2.0 * (100.0 - c)) + mid;\n} else if (c <= 0.0 && c > -100.0) {\nv = (200.0 * pixelValue - 100.0 * maxI + 2.0 * maxI * b) * (100.0 + c) / 20000.0 + mid;\n} else if (c == 100.0) {\nv = (200.0 * pixelValue - 100.0 * maxI + (maxI + 1.0) * (100.0 - c) + 2.0 * maxI * b);\nv = (sign(v) + 1.0) / 2.0;\n} else if (c == -100.0) {\nv = vec4(mid, mid, mid, currentPixel.a);\n}\nreturn vec4(v.r / 255.0, v.g / 255.0, v.b / 255.0, currentPixel.a);\n}","projection.glsl":"uniform sampler2D u_transformGrid;\nuniform vec2 u_transformSpacing;\nuniform vec2 u_transformGridSize;\nuniform vec2 u_targetImageSize;\nvec2 projectPixelLocation(vec2 coords) {\nvec2 index_image = floor(coords * u_targetImageSize);\nvec2 oneTransformPixel = vec2(0.25 / u_transformGridSize.s, 1.0 / u_transformGridSize.t);\nvec2 index_transform = floor(index_image / u_transformSpacing) / u_transformGridSize;\nvec2 pos = fract((index_image + vec2(0.5, 0.5)) / u_transformSpacing);\nvec2 srcLocation;\nvec2 transform_location = index_transform + oneTransformPixel * 0.5;\nif (pos.s <= pos.t) {\nvec4 ll_abc = texture2D(u_transformGrid, vec2(transform_location.s, transform_location.t));\nvec4 ll_def = texture2D(u_transformGrid, vec2(transform_location.s + oneTransformPixel.s, transform_location.t));\nsrcLocation.s = dot(ll_abc.rgb, vec3(pos, 1.0));\nsrcLocation.t = dot(ll_def.rgb, vec3(pos, 1.0));\n} else {\nvec4 ur_abc = texture2D(u_transformGrid, vec2(transform_location.s + 2.0 * oneTransformPixel.s, transform_location.t));\nvec4 ur_def = texture2D(u_transformGrid, vec2(transform_location.s + 3.0 * oneTransformPixel.s, transform_location.t));\nsrcLocation.s = dot(ur_abc.rgb, vec3(pos, 1.0));\nsrcLocation.t = dot(ur_def.rgb, vec3(pos, 1.0));\n}\nreturn srcLocation;\n}"},hillshade:{"hillshade.frag":"precision mediump float;\nvarying highp vec2 v_texcoord;\n#include <raster/common/common.glsl>\nuniform int u_hillshadeType;\nuniform float u_sinZcosAs[6];\nuniform float u_sinZsinAs[6];\nuniform float u_cosZs[6];\nuniform float u_weights[6];\nuniform vec2 u_factor;\nuniform float u_minValue;\nuniform float u_maxValue;\n#include <raster/lut/colorize.glsl>\nfloat getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nif (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {\nreturn 0.0;\n}\nelse {\nreturn e;\n}\n}\nvec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\nvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\nfloat d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec4 overlay(float val, float minValue, float maxValue, float hillshade) {\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\nvec4 rgb = colorize(vec4(val, val, val, 1.0), 255.0);\nvec3 hsv = rgb2hsv(rgb.xyz);\nhsv.z = hillshade;\nreturn vec4(hsv2rgb(hsv), 1.0) * rgb.a;\n}\nvoid main() {\nvec2 pixelLocation = getPixelLocation(v_texcoord);\nif (isOutside(pixelLocation)) {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\nif (currentPixel.a == 0.0) {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\nreturn;\n}\nvec2 axy = vec2(-1.0, -1.0);\nvec2 bxy = vec2(0.0, -1.0);\nvec2 cxy = vec2(1.0, -1.0);\nvec2 dxy = vec2(-1.0, 0.0);\nvec2 fxy = vec2(1.0, 0.0);\nvec2 gxy = vec2(-1.0, 1.0);\nvec2 hxy = vec2(0.0, 1.0);\nvec2 ixy = vec2(1.0, 1.0);\nvec2 onePixel = 1.0 / u_srcImageSize;\nif (pixelLocation.s < onePixel.s) {\naxy[0] = 1.0;\ndxy[0] = 1.0;\ngxy[0] = 1.0;\n}\nif (pixelLocation.t < onePixel.t) {\naxy[1] = 1.0;\nbxy[1] = 1.0;\ncxy[1] = 1.0;\n}\nif (pixelLocation.s > 1.0 - onePixel.s) {\ncxy[0] = -1.0;\nfxy[0] = -1.0;\nixy[0] = -1.0;\n}\nif (pixelLocation.t > 1.0 - onePixel.t) {\ngxy[1] = -1.0;\nhxy[1] = -1.0;\nixy[1] = -1.0;\n}\nvec4 va = texture2D(u_image, pixelLocation + onePixel * axy);\nvec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);\nvec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);\nvec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);\nvec4 ve = texture2D(u_image, pixelLocation);\nvec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);\nvec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);\nvec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);\nvec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);\nfloat dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\nfloat dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\nfloat dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\nfloat hillshade = 0.0;\nif (u_hillshadeType == 0){\nfloat cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\nfloat z = (u_cosZs[0] + cosDelta) / dzd;\nif (z < 0.0)  z = 0.0;\nhillshade = z;\n} else {\nfor (int k = 0; k < 6; k++) {\nfloat cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\nfloat z = (u_cosZs[k] + cosDelta) / dzd;\nif (z < 0.0) z = 0.0;\nhillshade = hillshade + z * u_weights[k];\nif (k == 5) break;\n}\n}\nfloat alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n#ifdef APPLY_COLORMAP\ngl_FragColor = overlay(ve.r, u_minValue, u_maxValue, hillshade) * alpha * u_opacity;\n#else\ngl_FragColor = vec4(hillshade, hillshade, hillshade, 1.0) * alpha * u_opacity;\n#endif\n}","hillshade.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform highp vec2 u_coordScale;\nvarying highp vec2 v_texcoord;\nvoid main()\n{\nv_texcoord = a_pos;\ngl_Position = vec4(u_dvsMat3 * vec3(a_pos * u_coordScale, 1.0), 1.0);\n}"},lut:{"colorize.glsl":"uniform sampler2D u_colormap;\nuniform float u_colormapOffset;\nuniform float u_colormapMaxIndex;\nvec4 colorize(vec4 currentPixel, float scaleFactor) {\nfloat clrIndex = clamp(currentPixel.r * scaleFactor - u_colormapOffset, 0.0, u_colormapMaxIndex);\nvec2 clrPosition = vec2((clrIndex + 0.5) / (u_colormapMaxIndex + 1.0), 0.0);\nvec4 color = texture2D(u_colormap, clrPosition);\nvec4 result = vec4(color.rgb, color.a * currentPixel.a);\nreturn result;\n}","lut.frag":"precision mediump float;\nvarying highp vec2 v_texcoord;\n#include <raster/common/common.glsl>\n#include <raster/lut/colorize.glsl>\nvoid main() {\nvec2 pixelLocation = getPixelLocation(v_texcoord);\nif (isOutside(pixelLocation)) {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\nvec4 result = colorize(currentPixel, 1.0);\ngl_FragColor = vec4(result.xyz, 1.0) * result.a * u_opacity;\n}","lut.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform highp vec2 u_coordScale;\nuniform highp float u_scale;\nuniform highp vec2 u_offset;\nvarying highp vec2 v_texcoord;\nvoid main()\n{\nv_texcoord = a_pos * u_scale + u_offset;\ngl_Position = vec4(u_dvsMat3 * vec3(a_pos * u_coordScale, 1.0), 1.0);\n}"},stretch:{"stretch.frag":"precision mediump float;\nvarying highp vec2 v_texcoord;\n#include <raster/common/common.glsl>\nuniform float u_minCutOff[3];\nuniform float u_maxCutOff[3];\nuniform float u_minOutput;\nuniform float u_maxOutput;\nuniform float u_factor[3];\nuniform bool u_useGamma;\nuniform float u_gamma[3];\nuniform float u_gammaCorrection[3];\n#include <raster/lut/colorize.glsl>\nfloat stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\nif (val >= maxCutOff) {\nreturn maxOutput;\n} else if (val <= minCutOff) {\nreturn minOutput;\n}\nfloat stretchedVal;\nif (useGamma) {\nfloat tempf = 1.0;\nfloat outRange = maxOutput - minOutput;\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\nif (gamma > 1.0) {\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\n}\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n} else {\nstretchedVal = minOutput + (val - minCutOff) * factor;\n}\nreturn stretchedVal;\n}\nvoid main() {\nvec2 pixelLocation = getPixelLocation(v_texcoord);\nif (isOutside(pixelLocation)) {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\n#ifdef NOOP\ngl_FragColor = vec4(currentPixel.rgb, 1.0) * currentPixel.a * u_opacity;\nreturn;\n#endif\nif (u_bandCount == 1) {\nfloat grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n#ifdef APPLY_COLORMAP\nvec4 result = colorize(vec4(grayVal, grayVal, grayVal, 1.0), u_useGamma ? 255.0 : 1.0);\ngl_FragColor = vec4(result.xyz, 1.0) * result.a * currentPixel.a * u_opacity;\n#else\ngl_FragColor = vec4(grayVal, grayVal, grayVal, 1.0) * currentPixel.a * u_opacity;\n#endif\n} else {\nfloat redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\nfloat greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\nfloat blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\ngl_FragColor = vec4(redVal, greenVal, blueVal, 1.0) * currentPixel.a * u_opacity;\n}\n}","stretch.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform highp vec2 u_coordScale;\nuniform highp float u_scale;\nuniform highp vec2 u_offset;\nvarying highp vec2 v_texcoord;\nvoid main()\n{\nv_texcoord = a_pos * u_scale + u_offset;\ngl_Position = vec4(u_dvsMat3 * vec3(a_pos * u_coordScale, 1.0), 1.0);\n}"}},stencil:{"stencil.frag":"void main() {\ngl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}","stencil.vert":"attribute vec2 a_pos;\nvoid main() {\ngl_Position = vec4(a_pos, 0.0, 1.0);\n}"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\nvoid main(void) {\nlowp vec4 color = texture2D(u_texture, v_tex);\ngl_FragColor = 0.75 * color;\n}","tileInfo.vert":"attribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_coord_ratio;\nuniform mediump vec2 u_delta;\nuniform mediump vec2 u_dimensions;\nvarying mediump vec2 v_tex;\nvoid main() {\nmediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\nvec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\ngl_Position = vec4(v_pos.xy, 0.0, 1.0);\nv_tex = a_pos;\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}"}};const K=new Y((function(e){let t=X;return e.split("/").forEach((e=>{t&&(t=t[e])})),t}));function J(e){return K.resolveIncludes(e)}J("background/background.vert"),J("background/background.frag"),new Map([["a_pos",0]]);var $=i(384);function Q(e){let t="";for(const i in e){const n=e[i];if("boolean"==typeof n)n&&(t+=`#define ${i}\n`);else if("number"==typeof n)t+=`#define ${i} ${n.toFixed()}\n`;else if("object"==typeof n){const e=n.options;let a=0;for(const i in e)t+=`#define ${e[i]} ${(a++).toFixed()}\n`;t+=`#define ${i} ${e[n.value]}\n`}}return t}J("tileInfo/tileInfo.vert"),J("tileInfo/tileInfo.frag"),new Map([["a_pos",0]]);var ee=i(10),te=i(701),ie=i(704);class ne extends q{constructor(){super(...arguments),this._color=Object(Z.c)(1,0,0,1),this._patternMatrix=Object(d.b)(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(e,t){const{context:i,painter:n,styleLayerUID:o}=e;this._loadWGLResources(e);const r=e.displayLevel,l=e.styleLayer,s=l.backgroundMaterial,c=n.vectorTilesMaterialManager,u=l.getPaintValue("background-color",r),f=l.getPaintValue("background-opacity",r),d=l.getPaintValue("background-pattern",r),_=void 0!==d,v=u[3]*f,m=1|window.devicePixelRatio,h=e.spriteMosaic;let p,g;const y=m>W.w?2:1,x=e.drawPhase===te.b.HITTEST,b=this._programOptions;b.id=x,b.pattern=_;const S=c.getMaterialProgram(i,s,b);if(i.bindVAO(this._vao),i.useProgram(S),_){const e=h.getMosaicItemPosition(d,!0);if(Object(a.j)(e)){const{tl:t,br:n,page:o}=e;p=n[0]-t[0],g=n[1]-t[1];const r=h.getPageSize(o);Object(a.j)(r)&&(h.bind(i,9729,o,W.y),S.setUniform4f("u_tlbr",t[0],t[1],n[0],n[1]),S.setUniform2fv("u_mosaicSize",r),S.setUniform1i("u_texture",W.y))}S.setUniform1f("u_opacity",f)}else this._color[0]=v*u[0],this._color[1]=v*u[1],this._color[2]=v*u[2],this._color[3]=v,S.setUniform4fv("u_color",this._color);if(S.setUniform1f("u_depth",l.z||0),x){const e=Object(ie.c)(o+1);S.setUniform4fv("u_id",e)}for(const a of t){if(S.setUniform1f("u_coord_range",a.coordRange[0]),S.setUniformMatrix3fv("u_dvsMat3",a.transforms.dvs),_){const e=Math.max(2**(Math.round(r)-a.key.level),1),t=y*a.size[0]*e,i=t/Object(ee.q)(p),n=t/Object(ee.q)(g);this._patternMatrix[0]=i,this._patternMatrix[4]=n,S.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}i.setStencilFunction(514,a.stencilRef,255),i.drawArrays(5,0,4)}}_loadWGLResources(e){if(this._vao)return;const{context:t,styleLayer:i}=e,n=i.backgroundMaterial,a=new Int8Array([0,0,1,0,0,1,1,1]),o=g.a.createVertex(t,35044,a),r=new x.a(t,n.getAttributeLocations(),n.getLayoutInfo(),{geometry:o});this._vao=r}}class ae extends q{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:n,requiredLevel:o,state:r,drawPhase:l,painter:s,spriteMosaic:c,styleLayerUID:u}=e;if(!t.some((e=>{var t,i;return null!=(t=null==(i=e.layerData.get(u))?void 0:i.circleIndexCount)&&t})))return;const f=e.styleLayer,d=f.circleMaterial,_=s.vectorTilesMaterialManager,v=f.getPaintValue("circle-translate",n),m=f.getPaintValue("circle-translate-anchor",n),h=l===te.b.HITTEST,p=this._programOptions;p.id=h;const g=_.getMaterialProgram(i,d,p);i.useProgram(g),g.setUniformMatrix3fv("u_displayMat3",1===m?r.displayMat3:r.displayViewMat3),g.setUniform2fv("u_circleTranslation",v),g.setUniform1f("u_depth",f.z),g.setUniform1f("u_antialiasingWidth",1.2);let y=-1;if(h){const e=Object(ie.c)(u+1);g.setUniform4fv("u_id",e)}for(const x of t){if(!x.layerData.has(u))continue;x.key.level!==y&&(y=x.key.level,d.setDataUniforms(g,n,f,y,c));const e=x.layerData.get(u);if(!e.circleIndexCount)continue;e.prepareForRendering(i);const t=e.circleVertexArrayObject;Object(a.i)(t)||(i.bindVAO(t),g.setUniformMatrix3fv("u_dvsMat3",x.transforms.dvs),o!==x.key.level?i.setStencilFunction(514,x.stencilRef,255):i.setStencilFunction(516,255,255),i.drawElements(4,e.circleIndexCount,5125,Uint32Array.BYTES_PER_ELEMENT*e.circleIndexStart),x.triangleCount+=e.circleIndexCount/3)}}}const oe=1/65536;class re extends q{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,t){const{displayLevel:i,drawPhase:n,renderPass:a,spriteMosaic:o,styleLayerUID:r}=e;let l=!1;for(const x of t)if(x.layerData.has(r)){const e=x.layerData.get(r);if(e.fillIndexCount>0||e.outlineIndexCount>0){l=!0;break}}if(!l)return;const s=e.styleLayer,c=s.getPaintProperty("fill-pattern"),u=void 0!==c,f=u&&c.isDataDriven;let d;if(u&&!f){const e=c.getValue(i);d=o.getMosaicItemPosition(e,!0)}const _=!u&&s.getPaintValue("fill-antialias",i);let v,m=!0,h=1;if(!u){const e=s.getPaintProperty("fill-color"),t=s.getPaintProperty("fill-opacity");if(!(null!=e&&e.isDataDriven||null!=t&&t.isDataDriven)){const e=s.getPaintValue("fill-color",i);h=s.getPaintValue("fill-opacity",i)*e[3],h>=1&&(m=!1)}}if(m&&"opaque"===a)return;n===te.b.HITTEST&&(v=Object(ie.c)(r+1));const p=s.getPaintValue("fill-translate",i),g=s.getPaintValue("fill-translate-anchor",i);(m||"translucent"!==a)&&this._drawFill(e,r,s,t,p,g,u,d,f,v);const y=!s.hasDataDrivenOutlineColor&&s.outlineUsesFillColor&&h<1;_&&"opaque"!==a&&!y&&this._drawOutline(e,r,s,t,p,g,v)}_drawFill(e,t,i,n,o,r,l,s,c,u){if(l&&Object(a.i)(s))return;const{context:f,displayLevel:d,state:_,drawPhase:v,painter:m,pixelRatio:h,spriteMosaic:p}=e,g=i.fillMaterial,y=m.vectorTilesMaterialManager,x=h>W.w?2:1,b=v===te.b.HITTEST,S=this._fillProgramOptions;S.id=b,S.pattern=l;const C=y.getMaterialProgram(f,g,S);if(f.useProgram(C),Object(a.j)(s)){const{page:e}=s,t=p.getPageSize(e);Object(a.j)(t)&&(p.bind(f,9729,e,W.y),C.setUniform2fv("u_mosaicSize",t),C.setUniform1i("u_texture",W.y))}C.setUniformMatrix3fv("u_displayMat3",1===r?_.displayMat3:_.displayViewMat3),C.setUniform2fv("u_fillTranslation",o),C.setUniform1f("u_depth",i.z+oe),b&&C.setUniform4fv("u_id",u);let T=-1;for(const w of n){if(!w.layerData.has(t))continue;w.key.level!==T&&(T=w.key.level,g.setDataUniforms(C,d,i,T,p));const e=w.layerData.get(t);if(!e.fillIndexCount)continue;e.prepareForRendering(f);const n=e.fillVertexArrayObject;if(!Object(a.i)(n)){if(f.bindVAO(n),C.setUniformMatrix3fv("u_dvsMat3",w.transforms.dvs),f.setStencilFunction(514,w.stencilRef,255),l){const e=Math.max(2**(Math.round(d)-w.key.level),1),t=w.coordRange[0]/(x*w.size[0]*e);C.setUniform1f("u_patternFactor",t)}if(c){const t=e.patternMap;if(!t)continue;for(const[e,i]of t){const t=p.getPageSize(e);Object(a.j)(t)&&(p.bind(f,9729,e,W.y),C.setUniform2fv("u_mosaicSize",t),C.setUniform1i("u_texture",W.y),f.drawElements(4,i[1],5125,Uint32Array.BYTES_PER_ELEMENT*i[0]))}}else f.drawElements(4,e.fillIndexCount,5125,Uint32Array.BYTES_PER_ELEMENT*e.fillIndexStart);w.triangleCount+=e.fillIndexCount/3}}}_drawOutline(e,t,i,n,o,r,l){const{context:s,displayLevel:c,state:u,drawPhase:f,painter:d,pixelRatio:_,spriteMosaic:v}=e,m=i.outlineMaterial,h=d.vectorTilesMaterialManager,p=.75/_,g=f===te.b.HITTEST,y=this._outlineProgramOptions;y.id=g;const x=h.getMaterialProgram(s,m,y);s.useProgram(x),x.setUniformMatrix3fv("u_displayMat3",1===r?u.displayMat3:u.displayViewMat3),x.setUniform2fv("u_fillTranslation",o),x.setUniform1f("u_depth",i.z+oe),x.setUniform1f("u_outline_width",p),g&&x.setUniform4fv("u_id",l);let b=-1;for(const S of n){if(!S.layerData.has(t))continue;S.key.level!==b&&(b=S.key.level,m.setDataUniforms(x,c,i,b,v));const e=S.layerData.get(t);if(e.prepareForRendering(s),!e.outlineIndexCount)continue;const n=e.outlineVertexArrayObject;Object(a.i)(n)||(s.bindVAO(n),x.setUniformMatrix3fv("u_dvsMat3",S.transforms.dvs),s.setStencilFunction(514,S.stencilRef,255),s.drawElements(4,e.outlineIndexCount,5125,Uint32Array.BYTES_PER_ELEMENT*e.outlineIndexStart),S.triangleCount+=e.outlineIndexCount/3)}}}class le extends q{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:n,state:o,drawPhase:r,painter:l,pixelRatio:s,spriteMosaic:c,styleLayerUID:u}=e;if(!t.some((e=>{var t,i;return null!=(t=null==(i=e.layerData.get(u))?void 0:i.lineIndexCount)&&t})))return;const f=e.styleLayer,d=f.lineMaterial,_=l.vectorTilesMaterialManager,v=f.getPaintValue("line-translate",n),m=f.getPaintValue("line-translate-anchor",n),h=f.getPaintProperty("line-pattern"),p=void 0!==h,g=p&&h.isDataDriven;let y,x;if(p&&!g){const e=h.getValue(n);y=c.getMosaicItemPosition(e)}let b=!1;if(!p){const e=f.getPaintProperty("line-dasharray");if(x=void 0!==e,b=x&&e.isDataDriven,x&&!b){const t=e.getValue(n),i=f.getDashKey(t,f.getLayoutValue("line-cap",n));y=c.getMosaicItemPosition(i)}}const S=1/s,C=r===te.b.HITTEST,T=this._programOptions;T.id=C,T.pattern=p,T.sdf=x;const w=_.getMaterialProgram(i,d,T);if(i.useProgram(w),w.setUniformMatrix3fv("u_displayViewMat3",o.displayViewMat3),w.setUniformMatrix3fv("u_displayMat3",1===m?o.displayMat3:o.displayViewMat3),w.setUniform2fv("u_lineTranslation",v),w.setUniform1f("u_depth",f.z),w.setUniform1f("u_antialiasing",S),C){const e=Object(ie.c)(u+1);w.setUniform4fv("u_id",e)}if(y&&Object(a.j)(y)){const{page:e}=y,t=c.getPageSize(e);Object(a.j)(t)&&(c.bind(i,9729,e,W.y),w.setUniform2fv("u_mosaicSize",t),w.setUniform1i("u_texture",W.y))}let I=-1;for(const D of t){if(!D.layerData.has(u))continue;D.key.level!==I&&(I=D.key.level,d.setDataUniforms(w,n,f,I,c));const e=2**(n-I)/s;w.setUniform1f("u_zoomFactor",e);const t=D.layerData.get(u);if(!t.lineIndexCount)continue;t.prepareForRendering(i);const o=t.lineVertexArrayObject;if(!Object(a.i)(o)){if(i.bindVAO(o),w.setUniformMatrix3fv("u_dvsMat3",D.transforms.dvs),i.setStencilFunction(514,D.stencilRef,255),g||b){const e=t.patternMap;if(!e)continue;for(const[t,n]of e){const e=c.getPageSize(t);Object(a.j)(e)&&(c.bind(i,9729,t,W.y),w.setUniform2fv("u_mosaicSize",e),w.setUniform1i("u_texture",W.y),i.drawElements(4,n[1],5125,Uint32Array.BYTES_PER_ELEMENT*n[0]))}}else i.drawElements(4,t.lineIndexCount,5125,Uint32Array.BYTES_PER_ELEMENT*t.lineIndexStart);D.triangleCount+=t.lineIndexCount/3}}}}var se=i(234),ce=i(807);class ue extends q{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=Object(se.a)()}dispose(){}drawMany(e,t){const{drawPhase:i,styleLayerUID:n}=e,a=e.styleLayer;let o;i===te.b.HITTEST&&(o=Object(ie.c)(n+1)),this._drawIcons(e,a,t,o),this._drawText(e,a,t,o)}_drawIcons(e,t,i,n){const{context:o,displayLevel:r,drawPhase:l,painter:s,spriteMosaic:c,state:u,styleLayerUID:f}=e,d=t.iconMaterial,_=s.vectorTilesMaterialManager;let v,m=!1;for(const a of i)if(a.layerData.has(f)&&(v=a.layerData.get(f),v.iconPerPageElementsMap.size>0)){m=!0;break}if(!m)return;const h=t.getPaintValue("icon-translate",r),p=t.getPaintValue("icon-translate-anchor",r);let g=t.getLayoutValue("icon-rotation-alignment",r);2===g&&(g=0===t.getLayoutValue("symbol-placement",r)?1:0);const y=0===g,x=t.getLayoutValue("icon-keep-upright",r)&&y,b=v.isIconSDF,S=l===te.b.HITTEST,C=this._iconProgramOptions;C.id=S,C.sdf=b;const T=_.getMaterialProgram(o,d,C);o.useProgram(T),T.setUniformMatrix3fv("u_displayViewMat3",0===g?u.displayViewMat3:u.displayMat3),T.setUniformMatrix3fv("u_displayMat3",1===p?u.displayMat3:u.displayViewMat3),T.setUniform2fv("u_iconTranslation",h),T.setUniform1f("u_depth",t.z),T.setUniform1f("u_mapRotation",Object(ce.b)(u.rotation)),T.setUniform1f("u_keepUpright",x?1:0),T.setUniform1f("u_level",10*r),T.setUniform1i("u_texture",W.y),T.setUniform1f("u_fadeDuration",R.c/1e3),S&&T.setUniform4fv("u_id",n);let w=-1;for(const I of i){if(!I.layerData.has(f))continue;if(I.key.level!==w&&(w=I.key.level,d.setDataUniforms(T,r,t,w,c)),v=I.layerData.get(f),0===v.iconPerPageElementsMap.size)continue;v.prepareForRendering(o),v.updateOpacityInfo();const i=v.iconVertexArrayObject;if(!Object(a.i)(i)){o.bindVAO(i),T.setUniformMatrix3fv("u_dvsMat3",I.transforms.dvs),T.setUniform1f("u_time",(performance.now()-v.lastOpacityUpdate)/1e3);for(const[t,i]of v.iconPerPageElementsMap)this._renderIconRange(e,T,i,t,I)}}}_renderIconRange(e,t,i,n,a){const{context:o,spriteMosaic:r}=e;this._spritesTextureSize[0]=r.getWidth(n)/4,this._spritesTextureSize[1]=r.getHeight(n)/4,t.setUniform2fv("u_mosaicSize",this._spritesTextureSize),r.bind(o,9729,n,W.y),o.setStencilTestEnabled(!0),o.setStencilFunction(516,255,255),o.setStencilWriteMask(0),o.drawElements(4,i[1],5125,Uint32Array.BYTES_PER_ELEMENT*i[0]),a.triangleCount+=i[1]/3}_drawText(e,t,i,n){const{context:o,displayLevel:r,drawPhase:l,glyphMosaic:s,painter:c,pixelRatio:u,spriteMosaic:f,state:d,styleLayerUID:_}=e,v=t.textMaterial,m=c.vectorTilesMaterialManager;let h,p=!1;for(const a of i)if(a.layerData.has(_)&&(h=a.layerData.get(_),h.glyphPerPageElementsMap.size>0)){p=!0;break}if(!p)return;const g=t.getPaintProperty("text-opacity");if(g&&!g.isDataDriven&&0===g.getValue(r))return;const y=t.getPaintProperty("text-color"),x=!y||y.isDataDriven||y.getValue(r)[3]>0,b=t.getPaintProperty("text-halo-width"),S=t.getPaintProperty("text-halo-color"),C=(!b||b.isDataDriven||b.getValue(r)>0)&&(!S||S.isDataDriven||S.getValue(r)[3]>0);if(!x&&!C)return;let T=t.getLayoutValue("text-rotation-alignment",r);2===T&&(T=0===t.getLayoutValue("symbol-placement",r)?1:0);const w=0===T,I=t.getLayoutValue("text-keep-upright",r)&&w,D=l===te.b.HITTEST,O=.8*3/u;this._glyphTextureSize||(this._glyphTextureSize=Object(se.b)(s.width/4,s.height/4));const z=t.getPaintValue("text-translate",r),P=t.getPaintValue("text-translate-anchor",r),A=this._sdfProgramOptions;A.id=D;const E=m.getMaterialProgram(o,v,A);o.useProgram(E),E.setUniformMatrix3fv("u_displayViewMat3",0===T?d.displayViewMat3:d.displayMat3),E.setUniformMatrix3fv("u_displayMat3",1===P?d.displayMat3:d.displayViewMat3),E.setUniform2fv("u_textTranslation",z),E.setUniform1f("u_depth",t.z+152587890625e-16),E.setUniform2fv("u_mosaicSize",this._glyphTextureSize),E.setUniform1f("u_mapRotation",Object(ce.b)(d.rotation)),E.setUniform1f("u_keepUpright",I?1:0),E.setUniform1f("u_level",10*r),E.setUniform1i("u_texture",W.x),E.setUniform1f("u_antialiasingWidth",O),E.setUniform1f("u_fadeDuration",R.c/1e3),D&&E.setUniform4fv("u_id",n);let M=-1;for(const V of i){if(!V.layerData.has(_))continue;if(V.key.level!==M&&(M=V.key.level,v.setDataUniforms(E,r,t,M,f)),h=V.layerData.get(_),0===h.glyphPerPageElementsMap.size)continue;h.prepareForRendering(o),h.updateOpacityInfo();const e=h.textVertexArrayObject;if(Object(a.i)(e))continue;o.bindVAO(e),E.setUniformMatrix3fv("u_dvsMat3",V.transforms.dvs),o.setStencilTestEnabled(!0),o.setStencilFunction(516,255,255),o.setStencilWriteMask(0);const i=(performance.now()-h.lastOpacityUpdate)/1e3;E.setUniform1f("u_time",i),h.glyphPerPageElementsMap.forEach(((e,t)=>{this._renderGlyphRange(o,e,t,s,E,C,x,V)}))}}_renderGlyphRange(e,t,i,n,a,o,r,l){n.bind(e,9729,i,W.x),o&&(a.setUniform1f("u_halo",1),e.drawElements(4,t[1],5125,Uint32Array.BYTES_PER_ELEMENT*t[0]),l.triangleCount+=t[1]/3),r&&(a.setUniform1f("u_halo",0),e.drawElements(4,t[1],5125,Uint32Array.BYTES_PER_ELEMENT*t[0]),l.triangleCount+=t[1]/3)}}i(464);i(706);i(176);const fe={vtlBackground:ne,vtlFill:re,vtlLine:le,vtlCircle:ae,vtlSymbol:ue};var de={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = mod(v_accumulatedDistance / v_patternSize.x, 1.0);\nmediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float lineHalfWidth = v_lineHalfWidth - 0.5 * u_antialiasing;\nmediump float lineWidthRatio = lineHalfWidth / sdfPatternHalfWidth;\nmediump float relativeTexX = mod((v_accumulatedDistance * 0.5) / (lineWidthRatio * v_patternSize.x), 1.0);\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * lineHalfWidth;\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};const _e=new Y((function(e){let t=de;return e.split("/").forEach((e=>{t&&(t=t[e])})),t}));function ve(e){return _e.resolveIncludes(e)}const me=e=>Q({ID:e.id,PATTERN:e.pattern}),he={shaders:e=>({vertexShader:me(e)+ve("background/background.vert"),fragmentShader:me(e)+ve("background/background.frag")})},pe=e=>Q({ID:e.id}),ge={shaders:e=>({vertexShader:pe(e)+ve("circle/circle.vert"),fragmentShader:pe(e)+ve("circle/circle.frag")})},ye=e=>Q({ID:e.id,PATTERN:e.pattern}),xe={shaders:e=>({vertexShader:ye(e)+ve("fill/fill.vert"),fragmentShader:ye(e)+ve("fill/fill.frag")})},be=e=>Q({ID:e.id}),Se={shaders:e=>({vertexShader:be(e)+ve("outline/outline.vert"),fragmentShader:be(e)+ve("outline/outline.frag")})},Ce=e=>Q({ID:e.id,SDF:e.sdf}),Te={shaders:e=>({vertexShader:Ce(e)+ve("icon/icon.vert"),fragmentShader:Ce(e)+ve("icon/icon.frag")})},we=e=>Q({ID:e.id,PATTERN:e.pattern,SDF:e.sdf}),Ie={shaders:e=>({vertexShader:we(e)+ve("line/line.vert"),fragmentShader:we(e)+ve("line/line.frag")})},De=e=>Q({ID:e.id}),Oe={shaders:e=>({vertexShader:De(e)+ve("text/text.vert"),fragmentShader:De(e)+ve("text/text.frag")})};var ze=class{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach((e=>e.dispose())),this._programByKey.clear()}getMaterialProgram(e,t,i){const n=t.key<<3|this._getMaterialOptionsValue(t.type,i);if(this._programByKey.has(n))return this._programByKey.get(n);const a=this._getProgramTemplate(t.type),{shaders:o}=a,{vertexShader:r,fragmentShader:l}=o(i),s=t.getShaderHeader(),c=t.getShaderMain(),u=r.replace("#pragma header",s).replace("#pragma main",c),f=new $.a(e,u,l,t.getAttributeLocations());return this._programByKey.set(n,f),f}_getMaterialOptionsValue(e,t){switch(e){case 0:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case 1:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case 2:return t.id?1:0;case 3:{const e=t;return(e.sdf?1:0)<<2|(e.pattern?1:0)<<1|(e.id?1:0)}case 4:{const e=t;return(e.sdf?1:0)<<1|(e.id?1:0)}case 5:case 6:return t.id?1:0;default:return 0}}_getProgramTemplate(e){switch(e){case 0:return he;case 5:return ge;case 1:return xe;case 4:return Te;case 3:return Ie;case 2:return Se;case 6:return Oe;default:return null}}};const Pe=1e-6;var Ae=class{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache=new Map,this._vtlMaterialManager=new ze}dispose(){this._brushCache&&(this._brushCache.forEach((e=>e.dispose())),this._brushCache=null),this._vtlMaterialManager=Object(a.f)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(e,t,i){const{context:n}=e,a=i.layers;i.backgroundBucketIds.length>0&&(e.renderPass="background",i.backgroundBucketIds.forEach((n=>this._renderStyleLayer(i.getLayerById(n),e,t,!0)))),n.setBlendingEnabled(!1),n.setDepthTestEnabled(!0),n.setDepthWriteEnabled(!0),n.setDepthFunction(515),e.renderPass="opaque";for(let o=a.length-1;o>=0;o--)this._renderStyleLayer(a[o],e,t,!1);n.setDepthWriteEnabled(!1),n.setBlendingEnabled(!0),n.setBlendFunctionSeparate(1,771,1,771),e.renderPass="translucent";for(let o=0;o<a.length;o++)this._renderStyleLayer(a[o],e,t,!1);n.setDepthTestEnabled(!1),e.renderPass="symbol";for(let o=0;o<a.length;o++)this._renderStyleLayer(a[o],e,t,!1);n.bindVAO()}_renderStyleLayer(e,t,i,n=!1){if(!(n||e&&i.layerData.has(e.uid)))return;const a=e.getLayoutProperty("visibility");if(a&&1===a.getValue())return;const{renderPass:o}=t;let r;switch(e.type){case 0:if("background"!==o)return;r="vtlBackground";break;case 1:if("opaque"!==o&&"translucent"!==t.renderPass)return;r="vtlFill";break;case 2:if("translucent"!==o)return;r="vtlLine";break;case 4:if("symbol"!==o)return;r="vtlCircle";break;case 3:if("symbol"!==o)return;r="vtlSymbol"}const l=t.displayLevel;void 0!==e.minzoom&&e.minzoom>l+Pe||void 0!==e.maxzoom&&e.maxzoom<=l-Pe||(t.styleLayerUID=e.uid,t.styleLayer=e,this.drawWithBrush(t,i,r))}drawWithBrush(e,t,i){if(!this._brushCache.has(i)){const e=fe[i];this._brushCache.set(i,new e)}this._brushCache.get(i).drawMany(e,[t])}},Ee=i(892),Me=i(564),Ve=i(589),Le=i(63),Re=i(562);let Fe=class extends(Object(Ve.a)(Object(Me.a)(Re.a))){constructor(e){super(e),this.type="vector-tile-3d"}initialize(){const e=Le.q.force512VTL?this.layer.tileInfo:this.layer.compatibleTileInfo256,t=this._getTileInfoSupportError(e,this.layer.fullExtent);if(t)return void this.addResolvingPromise(Promise.reject(t));const{basemapTerrain:i,spatialReference:n,pixelRatio:a}=this.view,l=Object(r.l)(this.view,"basemapTerrain.tilingSchemeLocked").then((()=>{const e=i.tilingScheme,t=e.pixelSize;let a;this.schemaHelper=new u.a(t,n.isGeographic),a=256===t?this.layer.compatibleTileInfo256:this.view.spatialReference.isGeographic?this.layer.compatibleTileInfo512:this.layer.tileInfo;const o=this._getTileInfoCompatibilityError(a,e);if(o)throw o;this._set("tileInfo",a)}));this._tileHandlerController=Object(o.e)();const s=this.view.resourceController;this._memCache=s.memoryController.getMemCache(this.layer.uid,(e=>e.release()));const{style:c,spriteUrl:f,glyphsUrl:d}=this.layer.currentStyleInfo,_=new Ee.a(c,{spriteUrl:f,glyphsUrl:d}),v=i.mapTileRequester;this._tileHandler=new G(this.layer,_,a,this._memCache,v);const m=this._tileHandlerController.signal,h=e=>s.schedule(e),p=this._tileHandler.start({signal:m,schedule:h}),g=this._tileHandler.spriteMosaic;g.then((e=>{!Object(o.o)(m)&&this._tileHandler&&(this.painter=new Ae(e,this._tileHandler.glyphMosaic))})),p.then((()=>this._tileHandlerController=null));const y=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=Object(o.e)(),this._memCache.clear();const{style:e,spriteUrl:t,glyphsUrl:i}=this.layer.currentStyleInfo,n=new Ee.a(e,{spriteUrl:t,glyphsUrl:i}),r=new G(this.layer,n,a,this._memCache,v),l=r.start({signal:this._tileHandlerController.signal,schedule:h}),s=r.spriteMosaic;l.then((()=>this._tileHandlerController=null)),this.updatingHandles.addPromise(Promise.all([l,s]).then((([,e])=>{const t=this._tileHandler,i=this.painter;this.painter=new Ae(e,r.glyphMosaic),this._tileHandler=r,this.emit("data-changed"),t.destroy(),i&&i.dispose()})))};this.updatingHandles.add(this,"layer.currentStyleInfo",y),this.updatingHandles.add(this,"view.pixelRatio",y);const x=Promise.all([l,p,g]);this.addResolvingPromise(x)}destroy(){this.painter=Object(a.f)(this.painter),this._tileHandlerController&&(this._tileHandlerController.abort(),this._tileHandlerController=null),Object(a.e)(this._tileHandler),this._memCache=Object(a.e)(this._memCache),this._tileHandler=null}get dataLevelRange(){const e=this.tileInfo.lods,t=e[0].scale,i=e[e.length-1].scale,n=this.levelRangeFromScaleRange(t,i);return 1===n.minLevel&&256===this.tileInfo.size[0]&&(n.minLevel=0),n}async fetchTile(e,t,i,n){return this._tileHandler.getVectorTile(e,t,i,n)}};Object(n.a)([Object(l.b)({aliasOf:"layer.fullExtent"})],Fe.prototype,"fullExtent",void 0),Object(n.a)([Object(l.b)()],Fe.prototype,"layer",void 0),Object(n.a)([Object(l.b)()],Fe.prototype,"tileInfo",void 0),Object(n.a)([Object(l.b)()],Fe.prototype,"dataLevelRange",null),Object(n.a)([Object(l.b)()],Fe.prototype,"updatingProgressValue",void 0),Fe=Object(n.a)([Object(c.a)("esri.views.3d.layers.VectorTileLayerView3D")],Fe);var Ue=Fe;t.default=Ue},701:function(e,t,i){"use strict";var n,a,o,r,l,s,c;i.d(t,"a",(function(){return r})),i.d(t,"b",(function(){return o})),i.d(t,"c",(function(){return n})),i.d(t,"d",(function(){return l})),i.d(t,"e",(function(){return s})),function(e){e[e.FILL=0]="FILL",e[e.LINE=1]="LINE",e[e.MARKER=2]="MARKER",e[e.TEXT=3]="TEXT",e[e.LABEL=4]="LABEL"}(n||(n={})),function(e){e[e.SUCCEEDED=0]="SUCCEEDED",e[e.FAILED_OUT_OF_MEMORY=1]="FAILED_OUT_OF_MEMORY"}(a||(a={})),function(e){e[e.NONE=0]="NONE",e[e.MAP=1]="MAP",e[e.LABEL=2]="LABEL",e[e.LABEL_ALPHA=4]="LABEL_ALPHA",e[e.HITTEST=8]="HITTEST",e[e.HIGHLIGHT=16]="HIGHLIGHT",e[e.CLIP=32]="CLIP",e[e.DEBUG=64]="DEBUG",e[e.NUM_DRAW_PHASES=9]="NUM_DRAW_PHASES"}(o||(o={})),function(e){e[e.SIZE=0]="SIZE",e[e.COLOR=1]="COLOR",e[e.OPACITY=2]="OPACITY",e[e.ROTATION=3]="ROTATION"}(r||(r={})),function(e){e[e.NONE=0]="NONE",e[e.OPACITY=1]="OPACITY",e[e.COLOR=2]="COLOR",e[e.ROTATION=4]="ROTATION",e[e.SIZE_MINMAX_VALUE=8]="SIZE_MINMAX_VALUE",e[e.SIZE_SCALE_STOPS=16]="SIZE_SCALE_STOPS",e[e.SIZE_FIELD_STOPS=32]="SIZE_FIELD_STOPS",e[e.SIZE_UNIT_VALUE=64]="SIZE_UNIT_VALUE"}(l||(l={})),function(e){e[e.MINMAX_TARGETS_OUTLINE=128]="MINMAX_TARGETS_OUTLINE",e[e.SCALE_TARGETS_OUTLINE=256]="SCALE_TARGETS_OUTLINE",e[e.FIELD_TARGETS_OUTLINE=512]="FIELD_TARGETS_OUTLINE",e[e.UNIT_TARGETS_OUTLINE=1024]="UNIT_TARGETS_OUTLINE"}(s||(s={})),function(e){e[e.SPRITE=0]="SPRITE",e[e.GLYPH=1]="GLYPH"}(c||(c={}))},704:function(e,t,i){"use strict";i.d(t,"a",(function(){return o})),i.d(t,"b",(function(){return r})),i.d(t,"c",(function(){return a}));const n=new Float32Array(1);new Uint32Array(n.buffer);function a(e){return[255&e,(65280&e)>>>8,(16711680&e)>>>16,(4278190080&e)>>>24]}function o(e,t){return 65535&e|t<<16}function r(e,t,i,n){return 255&e|(255&t)<<8|(255&i)<<16|n<<24}},706:function(e,t,i){"use strict";i.d(t,"a",(function(){return v})),i.d(t,"b",(function(){return g})),i.d(t,"c",(function(){return h})),i.d(t,"d",(function(){return m})),i.d(t,"e",(function(){return c})),i.d(t,"f",(function(){return p})),i.d(t,"g",(function(){return l})),i.d(t,"h",(function(){return s}));var n=i(11),a=i(701),o=i(836);function r(e,t=!1){const i=a.d.SIZE_FIELD_STOPS|a.d.SIZE_MINMAX_VALUE|a.d.SIZE_SCALE_STOPS|a.d.SIZE_UNIT_VALUE,n=(e&(a.e.FIELD_TARGETS_OUTLINE|a.e.MINMAX_TARGETS_OUTLINE|a.e.SCALE_TARGETS_OUTLINE|a.e.UNIT_TARGETS_OUTLINE))>>>4;return t?i&n:i&~n}function l(e,t,i,n,o){switch(e){case a.c.FILL:return v.from(t,n);case a.c.LINE:return h.from(t,i);case a.c.MARKER:return m.from(t);case a.c.TEXT:return p.from(t);case a.c.LABEL:return g.from(t,o);default:throw new Error(`Unable to createMaterialKey for unknown geometryType ${e}`)}}function s(e){switch(c.load(e).geometryType){case a.c.MARKER:return new m(e);case a.c.FILL:return new v(e);case a.c.LINE:return new h(e);case a.c.TEXT:return new p(e);case a.c.LABEL:return new g(e)}}class c{constructor(e){this._data=0,this._data=e}static load(e){const t=this.shared;return t.data=e,t}set data(e){this._data=e}get data(){return this._data}get geometryType(){return this.bits(8,11)}set geometryType(e){this.setBits(e,8,11)}get mapAligned(){return!!this.bit(20)}set mapAligned(e){this.setBit(20,e)}get sdf(){return!!this.bit(11)}set sdf(e){this.setBit(11,e)}get pattern(){return!!this.bit(12)}set pattern(e){this.setBit(12,e)}get textureBinding(){return this.bits(0,8)}set textureBinding(e){this.setBits(e,0,8)}get geometryTypeString(){switch(this.geometryType){case a.c.FILL:return"fill";case a.c.MARKER:return"marker";case a.c.LINE:return"line";case a.c.TEXT:return"text";case a.c.LABEL:return"label";default:throw new n.a(`Unable to handle unknown geometryType: ${this.geometryType}`)}}setBit(e,t){const i=1<<e;t?this._data|=i:this._data&=~i}bit(e){return(this._data&1<<e)>>e}setBits(e,t,i){for(let n=t,a=0;n<i;n++,a++)this.setBit(n,0!=(e&1<<a))}bits(e,t){let i=0;for(let n=e,a=0;n<t;n++,a++)i|=this.bit(n)<<a;return i}hasVV(){return!1}setVV(e,t){}getVariation(){return{mapAligned:this.mapAligned,pattern:this.pattern,sdf:this.sdf}}getVariationHash(){return this._data&~(7&this.textureBinding)}}c.shared=new c(0);const u=e=>class extends e{get vvSizeMinMaxValue(){return 0!==this.bit(16)}set vvSizeMinMaxValue(e){this.setBit(16,e)}get vvSizeScaleStops(){return 0!==this.bit(17)}set vvSizeScaleStops(e){this.setBit(17,e)}get vvSizeFieldStops(){return 0!==this.bit(18)}set vvSizeFieldStops(e){this.setBit(18,e)}get vvSizeUnitValue(){return 0!==this.bit(19)}set vvSizeUnitValue(e){this.setBit(19,e)}hasVV(){return super.hasVV()||this.vvSizeMinMaxValue||this.vvSizeScaleStops||this.vvSizeFieldStops||this.vvSizeUnitValue}setVV(e,t){super.setVV(e,t);const i=r(e,t)&e;this.vvSizeMinMaxValue=!!(i&a.d.SIZE_MINMAX_VALUE),this.vvSizeFieldStops=!!(i&a.d.SIZE_FIELD_STOPS),this.vvSizeUnitValue=!!(i&a.d.SIZE_UNIT_VALUE),this.vvSizeScaleStops=!!(i&a.d.SIZE_SCALE_STOPS)}},f=e=>class extends e{get vvRotation(){return 0!==this.bit(15)}set vvRotation(e){this.setBit(15,e)}hasVV(){return super.hasVV()||this.vvRotation}setVV(e,t){super.setVV(e,t),this.vvRotation=!t&&!!(e&a.d.ROTATION)}},d=e=>class extends e{get vvColor(){return 0!==this.bit(13)}set vvColor(e){this.setBit(13,e)}hasVV(){return super.hasVV()||this.vvColor}setVV(e,t){super.setVV(e,t),this.vvColor=!t&&!!(e&a.d.COLOR)}},_=e=>class extends e{get vvOpacity(){return 0!==this.bit(14)}set vvOpacity(e){this.setBit(14,e)}hasVV(){return super.hasVV()||this.vvOpacity}setVV(e,t){super.setVV(e,t),this.vvOpacity=!t&&!!(e&a.d.OPACITY)}};class v extends(d(_(c))){static load(e){const t=this.shared;return t.data=e,t}static from(e,t){const i=this.load(0);return i.geometryType=a.c.FILL,t?i.dotDensity=!0:i.setVV(e,!1),i.data}getVariation(){return{...super.getVariation(),dotDensity:this.dotDensity,vvColor:this.vvColor,vvOpacity:this.vvOpacity}}get dotDensity(){return!!this.bit(15)}set dotDensity(e){this.setBit(15,e)}}v.shared=new v(0);class m extends(d(_(f(u(c))))){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(0);return t.geometryType=a.c.MARKER,t.setVV(e,!1),t.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvRotation:this.vvRotation,vvOpacity:this.vvOpacity,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}m.shared=new m(0);class h extends(d(_(u(c)))){static load(e){const t=this.shared;return t.data=e,t}static from(e,t){const i=this.load(0);return i.geometryType=a.c.LINE,i.setVV(e,t),i.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvOpacity:this.vvOpacity,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}h.shared=new h(0);class p extends(d(_(f(u(c))))){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(e);return t.geometryType=a.c.TEXT,t.setVV(e,!1),t.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvOpacity:this.vvOpacity,vvRotation:this.vvRotation,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}p.shared=new p(0);class g extends(u(c)){static load(e){const t=this.shared;return t.data=e,t}static from(e,t){const i=this.load(0);return i.geometryType=a.c.LABEL,i.setVV(e,!1),i.mapAligned=Object(o.a)(t),i.data}getVariation(){return{...super.getVariation(),vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}g.shared=new g(0)},717:function(e,t,i){"use strict";i.d(t,"a",(function(){return r})),i.d(t,"b",(function(){return o})),i.d(t,"c",(function(){return l})),i.d(t,"d",(function(){return s}));var n=i(704);function a(e,t){return Array.isArray(t)?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3]):(e[0]=t.r,e[1]=t.g,e[2]=t.b,e[3]=t.a),e}function o(e,t=0,i=!1){const n=e[t+3];return e[t+0]*=n,e[t+1]*=n,e[t+2]*=n,i||(e[t+3]*=255),e}function r(e){return o(a([],e))}function l(e){if(!e)return 0;const{r:t,g:i,b:a,a:o}=e;return Object(n.b)(t*o,i*o,a*o,255*o)}function s(e){if(!e)return 0;const[t,i,a,o]=e;return Object(n.b)(t*(o/255),i*(o/255),a*(o/255),o)}},719:function(e,t,i){"use strict";i.d(t,"a",(function(){return E})),i.d(t,"b",(function(){return M})),i.d(t,"c",(function(){return T})),i.d(t,"d",(function(){return w})),i.d(t,"e",(function(){return O})),i.d(t,"f",(function(){return S})),i.d(t,"g",(function(){return I})),i.d(t,"h",(function(){return C}));var n=i(11),a=i(7),o=(i(10),i(17),i(717),i(701)),r=i(104);class l{constructor(){this.color=[0,0,0,0],this.haloColor=[0,0,0,0],this.haloSize=0,this.size=12,this.angle=0,this.offsetX=0,this.offsetY=0,this.hAnchor=0,this.vAnchor=0}acquire(e,t,i,n,a,o,r,l,s){this.color=e,this.haloColor=t,this.haloSize=i,this.size=n,this.angle=a,this.offsetX=o,this.offsetY=r,this.hAnchor=l,this.vAnchor=s}release(){this.color[0]=this.color[1]=this.color[2]=this.color[3]=0,this.haloColor[0]=this.haloColor[1]=this.haloColor[2]=this.haloColor[3]=0,this.haloSize=0,this.size=0,this.angle=0,this.offsetX=0,this.offsetY=0,this.hAnchor=0,this.vAnchor=0}}l.pool=new r.a(l);i(47);const s=a.a.getLogger("esri.views.2d.engine.webgl.Utils"),c="geometry",u=[{name:c,strideInBytes:36,divisor:0}],f=[{name:c,strideInBytes:12,divisor:0}],d=[{name:c,strideInBytes:40,divisor:0}],_=[{name:c,strideInBytes:36,divisor:0}],v=[{name:c,strideInBytes:36,divisor:0}];function m(e){const t={};for(const i of e)t[i.name]=i.strideInBytes;return t}const h=m([{name:c,strideInBytes:36,divisor:0}]),p=m(u),g=m(f),y=m(d),x=m(_),b=m(v);function S(e,t){switch(e){case o.c.MARKER:return h;case o.c.FILL:return t?g:p;case o.c.LINE:return y;case o.c.TEXT:return x;case o.c.LABEL:return b}}function C(e){return"number"==typeof e}function T(e){switch(e){case"butt":return 0;case"round":return 1;case"square":return 2;default:return s.error(new n.a("mapview-invalid-type",`Cap type ${e} is not a valid option. Defaulting to round`)),1}}function w(e){switch(e){case"miter":return 2;case"bevel":return 0;case"round":return 1;default:return s.error(new n.a("mapview-invalid-type",`Join type ${e} is not a valid option. Defaulting to round`)),1}}function I(e){switch(e){case"opacity":return o.a.OPACITY;case"color":return o.a.COLOR;case"rotation":return o.a.ROTATION;case"size":return o.a.SIZE;default:return s.error(`Cannot interpret unknown vv: ${e}`),null}}function D(e){switch(e){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5126:case 5124:case 5125:return 4}}function O(e){switch(e){case 5121:return Uint8Array;case 32819:return Uint16Array;case 5126:return Float32Array;default:return void s.error(new n.a("webgl-utils",`Unable to handle type ${e}`))}}const z=e=>{const t=new Map;for(const i in e)for(const n of e[i])t.set(n.name,n.location);return t},P=e=>{const t={};for(const i in e){const n=e[i];t[i]=n.length?n[0].stride:0}return t},A=new Map,E=(e,t)=>{if(!A.has(e)){const i=function(e){const t={};for(const i in e){const n=e[i];let a=0;t[i]=n.map((e=>{const t={...e,normalized:e.normalized||!1,divisor:e.divisor||0,offset:a,stride:0};return a+=e.count*D(e.type),t})),t[i].forEach((e=>e.stride=a))}return t}(t),n={strides:P(i),bufferLayouts:i,attributes:z(t)};A.set(e,n)}return A.get(e)};function M(e){e(o.c.FILL),e(o.c.LINE),e(o.c.MARKER),e(o.c.TEXT),e(o.c.LABEL)}},722:function(e,t,i){"use strict";i.d(t,"a",(function(){return T}));var n=i(0),a=i(84),o=i(19),r=i(11),l=i(42),s=i(7),c=i(582),u=i(59),f=i(12),d=i(128),_=i(25),v=i(23),m=i(1),h=(i(8),i(45)),p=i(4),g=i(87),y=i(13);class x{constructor(){this.location={left:0,top:0,width:0,height:0},this._allAvailability="unknown",this.byteSize=40}getAvailability(e,t){if("unknown"!==this._allAvailability)return this._allAvailability;const i=(e-this.location.top)*this.location.width+(t-this.location.left),n=i%8,a=i>>3,o=this._tileAvailabilityBitSet;return a<0||a>o.length?"unknown":o[a]&1<<n?"available":"unavailable"}_updateFromData(e){const t=this.location.width,i=this.location.height;let n=!0,a=!0;const o=Math.ceil(t*i/8),r=new Uint8Array(o);let l=0;for(let s=0;s<e.length;s++){const t=s%8;e[s]?(a=!1,r[l]|=1<<t):n=!1,7===t&&++l}a?this._allAvailability="unavailable":n?this._allAvailability="available":(this._allAvailability="unknown",this._tileAvailabilityBitSet=r,this.byteSize+=r.length)}static fromDefinition(e,t){const i=e.service.request||a.default,{row:n,col:o,width:l,height:s}=e,c={query:{f:"json"}};return t=t?{...c,...t}:c,i(function(e){let t;if("vector-tile"===e.service.type)t=`${e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`;else{const i=e.service.tileServers;t=`${i&&i.length?i[e.row%i.length]:e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}const i=e.service.query;return i&&(t=`${t}?${i}`),t}(e),t).then((e=>e.data)).catch((e=>{if(e&&e.details&&422===e.details.httpStatus)return{location:{top:n,left:o,width:l,height:s},valid:!0,data:Object(g.c)(l*s,0)};throw e})).then((e=>{if(e.location&&(e.location.top!==n||e.location.left!==o||e.location.width!==l||e.location.height!==s))throw new r.a("tilemap:location-mismatch","Tilemap response for different location than requested",{response:e,definition:{top:n,left:o,width:l,height:s}});return x.fromJSON(e)}))}static fromJSON(e){x.validateJSON(e);const t=new x;return t.location=Object.freeze(Object(y.a)(e.location)),t._updateFromData(e.data),Object.freeze(t)}static validateJSON(e){if(!e||!e.location)throw new r.a("tilemap:missing-location","Location missing from tilemap response");if(!1===e.valid)throw new r.a("tilemap:invalid","Tilemap response was marked as invalid");if(!e.data)throw new r.a("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(e.data))throw new r.a("tilemap:data-mismatch","Data must be an array of numbers");if(e.data.length!==e.location.width*e.location.height)throw new r.a("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function b(e){return`${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}var S;const C=s.a.getLogger("esri.layers.support.TilemapCache");let T=S=class extends o.a{constructor(e){super(e),this._handles=new l.a,this._pendingTilemapRequests={},this._availableLevels={},this.levels=5,this.cacheByteSize=2097152,this.request=a.default,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new c.a(this.cacheByteSize),this._handles.add([this.watch(["layer.parsedUrl","layer.tileServers?"],(()=>this._initializeTilemapDefinition())),Object(v.a)(this,"layer.tileInfo.lods",(e=>this._initializeAvailableLevels(e)),!0)]),this._initializeTilemapDefinition()}destroy(){this._handles&&(this._handles.destroy(),this._handles=null)}castLevels(e){return e<=2?(C.error("Minimum levels for Tilemap is 3, but got ",e),3):e}get size(){return 1<<this.levels}fetchTilemap(e,t,i,n){if(!this._availableLevels[e])return Promise.reject(new r.a("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const a=this._tmpTilemapDefinition,o=this._tilemapFromCache(e,t,i,a);if(o)return Promise.resolve(o);const l=n&&n.signal;return n={...n,signal:null},new Promise(((e,t)=>{Object(f.s)(l,(()=>t(Object(f.f)())));const i=b(a);let o=this._pendingTilemapRequests[i];if(!o){o=x.fromDefinition(a,n).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>delete this._pendingTilemapRequests[i];this._pendingTilemapRequests[i]=o,o.then(e,e)}o.then(e,t)}))}getAvailability(e,t,i){if(!this._availableLevels[e])return"unavailable";const n=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return n?n.getAvailability(t,i):"unknown"}getAvailabilityUpsample(e,t,i,n){n.level=e,n.row=t,n.col=i;const a=this.layer.tileInfo;for(a.updateTileInfo(n);;){const e=this.getAvailability(n.level,n.row,n.col);if("unavailable"!==e)return e;if(!a.upsampleTile(n))return"unavailable"}}fetchAvailability(e,t,i,n){return this._availableLevels[e]?this.fetchTilemap(e,t,i,n).catch((e=>e)).then((n=>{if(n instanceof x){const a=n.getAvailability(t,i);return"unavailable"===a?Promise.reject(new r.a("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i})):a}if(Object(f.n)(n))throw n;return"unknown"})):Promise.reject(new r.a("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`))}fetchAvailabilityUpsample(e,t,i,n,a){n.level=e,n.row=t,n.col=i;const o=this.layer.tileInfo;o.updateTileInfo(n);const r=this.fetchAvailability(e,t,i,a).catch((e=>{if(Object(f.n)(e))throw e;if(o.upsampleTile(n))return this.fetchAvailabilityUpsample(n.level,n.row,n.col,n);throw e}));return this._fetchAvailabilityUpsamplePrefetch(n.id,e,t,i,a,r),r}async _fetchAvailabilityUpsamplePrefetch(e,t,i,n,a,o){if(!this._prefetchingEnabled)return;const r=`prefetch-${e}`;if(this._handles.has(r))return;const l=Object(f.e)();o.then((()=>l.abort()),(()=>l.abort()));let s=!1;const c={remove(){s||(s=!0,l.abort())}};if(this._handles.add(c,r),await Object(d.d)(10,l.signal).catch((()=>{})),s||(s=!0,this._handles.remove(r)),Object(f.o)(l))return;const u={id:e,level:t,row:i,col:n},_={...a,signal:l.signal},v=this.layer.tileInfo;for(let f=0;S._prefetches.length<S._maxPrefetch&&v.upsampleTile(u);++f){const e=this.fetchAvailability(u.level,u.row,u.col,_);S._prefetches.push(e);const t=()=>{S._prefetches.removeUnordered(e)};e.then(t,t)}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const e=this.layer.parsedUrl,t=e.query;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:t?Object(_.E)(t):null,tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,i,n){n.level=e,n.row=t-t%this.size,n.col=i-i%this.size;const a=b(n);return this._tilemapCache.get(a)}_initializeAvailableLevels(e){this._availableLevels={},e&&e.forEach((e=>this._availableLevels[e.level]=!0))}get test(){const e=this;return{get prefetchingEnabled(){return e._prefetchingEnabled},set prefetchingEnabled(t){e._prefetchingEnabled=t},hasTilemap:(t,i,n)=>!!e._tilemapFromCache(t,i,n,e._tmpTilemapDefinition)}}};T._maxPrefetch=4,T._prefetches=new u.a({initialSize:S._maxPrefetch}),Object(n.a)([Object(m.b)({constructOnly:!0,type:Number})],T.prototype,"levels",void 0),Object(n.a)([Object(h.a)("levels")],T.prototype,"castLevels",null),Object(n.a)([Object(m.b)({readOnly:!0,type:Number})],T.prototype,"size",null),Object(n.a)([Object(m.b)({constructOnly:!0,type:Number})],T.prototype,"cacheByteSize",void 0),Object(n.a)([Object(m.b)({constructOnly:!0})],T.prototype,"layer",void 0),Object(n.a)([Object(m.b)({constructOnly:!0})],T.prototype,"request",void 0),T=S=Object(n.a)([Object(p.a)("esri.layers.support.TilemapCache")],T)},780:function(e,t,i){"use strict";t.a=class{constructor(e=0,t=0,i=0,n=0){this.x=e,this.y=t,this.width=i,this.height=n}get isEmpty(){return this.width<=0||this.height<=0}union(e){this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.width=Math.max(this.width,e.width),this.height=Math.max(this.height,e.height)}}},807:function(e,t,i){"use strict";i.d(t,"a",(function(){return s})),i.d(t,"b",(function(){return l})),i.d(t,"c",(function(){return r}));Number.POSITIVE_INFINITY;const n=Math.PI,a=128/n;Math.LN2;function o(e,t){return(e%=t)>=0?e:e+t}function r(e){return o(e*a,256)}function l(e){return o(.7111111111111111*e,256)}function s(e,t,i){return e>=t&&e<=i||e>=i&&e<=t}},836:function(e,t,i){"use strict";function n(e){switch(e){case"above-along":case"below-along":case"center-along":case"esriServerLinePlacementAboveAlong":case"esriServerLinePlacementBelowAlong":case"esriServerLinePlacementCenterAlong":return!0;default:return!1}}i.d(t,"a",(function(){return n}))},911:function(e,t,i){"use strict";var n=i(588),a=i(410);t.a=class{constructor(e,t){this.lockedSchemaPixelSize=e,this.isGCS=t}getLevelRowColumn(e){return this.isGCS?[e[0],e[1]>>1,e[2]>>1]:256===this.lockedSchemaPixelSize&&e[0]>0?[e[0]-1,e[1]>>1,e[2]>>1]:e}adjustLevel(e){return this.isGCS?e:256===this.lockedSchemaPixelSize?e>0?e-1:0:e}getShift(e,t){let i=0,n=0;return(256===this.lockedSchemaPixelSize||this.isGCS)&&(e[2]%2&&(i=t),e[1]%2&&(n=t)),[i,n]}getScale(e){if(this.isGCS){if(512===this.lockedSchemaPixelSize)return 4}else if(256===this.lockedSchemaPixelSize&&0===e)return 1;return 2}static create256x256CompatibleTileInfo(e){if(!e)return null;if(256===e.size[0]&&256===e.size[1])return e;const t=e.spatialReference.isGeographic,i=[],o=e.lods.length;for(let a=0;a<o;a++){const o=e.lods[a],r=t?o.resolution:2*o.resolution;i.push(new n.a({level:o.level,scale:o.scale,resolution:r}))}return new a.a({size:[256,256],dpi:e.dpi,format:e.format,compressionQuality:e.compressionQuality,origin:e.origin,spatialReference:e.spatialReference,lods:i})}static create512x512CompatibleTileInfo(e){if(!e)return null;if(256===e.size[0]||256===e.size[1])return null;const t=[],i=e.lods.length;for(let a=0;a<i;a++){const i=e.lods[a],o=.5*i.resolution;t.push(new n.a({level:i.level,scale:i.scale,resolution:o}))}return new a.a({size:[512,512],dpi:e.dpi,format:e.format,compressionQuality:e.compressionQuality,origin:e.origin,spatialReference:e.spatialReference,lods:t})}}},912:function(e,t,i){"use strict";var n=i(12),a=i(722),o=i(574);t.a=class{constructor(e){if(e instanceof a.a)this._tilemapCache=e;else{if(!e||!("index"in e))throw new Error("Invalid tilemap!");this._tilemap=e.index}}dataKey(e,t){if(this._tilemapCache){const{level:i,row:a,col:r}=e,l=new o.a(e);return this._tilemapCache.fetchAvailabilityUpsample(i,a,r,l,t).then((()=>(l.world=e.world,l))).catch((e=>{if(Object(n.n)(e))throw e;return null}))}return this._getIndexedDataKey(e)}forEach(e,t,i,n,a){this._callback=a,this._maxLevel=t+e,this._forEach(this._tilemap,t,i,n)}_forEach(e,t,i,n){0!==e&&(this._callback(t,i,n),t!==this._maxLevel&&"object"==typeof e&&(this._forEach(e[0],t+1,2*i,2*n),this._forEach(e[1],t+1,2*i,2*n+1),this._forEach(e[2],t+1,2*i+1,2*n),this._forEach(e[3],t+1,2*i+1,2*n+1)))}_getIndexedDataKey(e){const t=[e];if(e.level<0||e.row<0||e.col<0||e.row>>e.level>0||e.col>>e.level>0)return Promise.resolve(null);let i=e;for(;0!==i.level;)i=new o.a(i.level-1,i.row>>1,i.col>>1,i.world),t.push(i);let n,a,r=this._tilemap,l=t.pop();if(1===r)return Promise.resolve(l);for(;t.length;)if(n=t.pop(),a=(1&n.col)+((1&n.row)<<1),r){if(0===r[a]){l=null;break}if(1===r[a]){l=n;break}l=n,r=r[a]}return Promise.resolve(l)}}}}]);
//# sourceMappingURL=42.a1a407a7.chunk.js.map