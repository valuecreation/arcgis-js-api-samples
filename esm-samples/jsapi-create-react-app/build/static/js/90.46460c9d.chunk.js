(this["webpackJsonpjsapi-create-react-app"]=this["webpackJsonpjsapi-create-react-app"]||[]).push([[90],{1156:function(e,t,i){"use strict";i.r(t);var s=i(0),r=i(2),n=i(1),a=(i(8),i(9),i(7),i(4)),o=i(946),h=i(564),c=i(19),l=i(42),d=i(36),p=i(53),u=i(10),g=i(901),m=i(270),b=i(18),j=i(27),_=i(3),O=i(5),f=i(31),y=i(39),v=i(444),w=i(782),L=i(144),S=i(902),P=i(67);function C(e,t,i){const s={distance:null};return Object(S.b)(s,[e[0],e[1]],[t[0],t[1]],i),s.distance}function x(e,t,i){const s=t[0]-e[0],r=t[1]-e[1],n=i[0]-e[0],a=i[1]-e[1];return.5*Math.abs(s*a-r*n)}function V(e,t,i,s){const r=R;return Object(d.A)(e,s,M)&&Object(d.A)(t,s,A)&&Object(d.A)(i,s,z)?(r.setPoint(0,0,M),r.setPoint(0,1,A),r.setPoint(0,2,z),Math.abs(Object(w.geodesicArea)(r,"square-meters"))):0}const M=Object(O.e)(),A=Object(O.e)(),z=Object(O.e)(),R=new L.a({rings:[[M,A,z]],spatialReference:y.a.WGS84}),G=Object(O.e)();var D=i(950);class E{constructor(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=Object(O.e)(),this.areaCentroidRenderCoords=Object(O.e)(),this.geodesicAreaCentroidRenderCoords=Object(O.e)(),this._length=0,this._centroidRenderCoords=Object(O.e)(),this._planeWorldCoords=Object(f.e)(),this._worldUp=Object(O.e)(),this._worldTangent=Object(O.e)(),this._frame=[Object(O.e)(),Object(O.e)(),Object(O.e)()],this._pathVersion=-1,this._validMeasurement=!1,this._tempU=Object(O.e)(),this._tempV=Object(O.e)(),this._tempVec3=Object(O.e)(),this._tempSphere={center:Object(O.e)(),radius:0},this._sceneView=e,this.unitNormalizer=t}update(e,t,i,s){const r=this.unitNormalizer,n=this._sceneView.renderSpatialReference,a=this.unitNormalizer.spatialReference;if(this._pathVersion===e.version&&this._validMeasurement===i)return;this._pathVersion=e.version,this._validMeasurement=i;const o=e.numVertices;this._resize(o);const h=Object(p.g)(t.spatialReference),c=Object(d.b)(t.spatialReference,h)&&Object(d.a)(t.spatialReference),l=this.positionsGeographic,u=this.positionsWorldCoords,m=this.positionsRenderCoords,b=this.positionsSpherical;e.forEachVertexPosition(((e,t)=>{Object(d.u)(e,u[t],a),Object(d.u)(e,m[t],n),c&&(Object(d.v)(e,l[t]),Object(d.u)(e,b[t],h),Object(_.t)(b[t],b[t]))}));const j=this._updatePathLengths(i);if(this.pathLength=this._length>1?new g.a(r.normalizeDistance(j),"meters"):null,c){const e=this._updateGeodesicPathLengths(i,a);this.geodesicPathLength=this._length>1?new g.a(e,"meters"):null}else this.geodesicPathLength=null;if(!i)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),void this.geodesicIntersectingSegments.clear();this._updateArea(t,r,n,a,s),c&&this._updateGeodesicArea(t)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,unitNormalizer:this.unitNormalizer}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(Object(O.e)()),this.positionsRenderCoords.push(Object(O.e)()),this.positionsProjectedWorldCoords.push(Object(j.b)()),this.positionsFittedRenderCoords.push(Object(O.e)()),this.positionsGeographic.push(Object(O.e)()),this.positionsSpherical.push(Object(O.e)()),this.positionsStereographic.push(Object(j.b)()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorldCoords,i=this.pathSegmentLengths;let s=0;for(let r=0;r<this._length;++r){const n=i[r]=Object(_.o)(t[r],t[(r+1)%this._length]);(r<this._length-1||e)&&(s+=n)}return s}_updateGeodesicPathLengths(e,t){const i=this.positionsGeographic,s=this.geodesicPathSegmentLengths;let r=0;for(let n=0;n<this._length;++n){const a=s[n]=C(i[n],i[(n+1)%this._length],t);(n<this._length-1||e)&&(r+=a)}return r}_updateArea(e,t,i,s,r){const n=e.renderCoordsHelper,a=this.positionsWorldCoords,o=this.positionsRenderCoords,h=this.positionsProjectedWorldCoords,c=this.positionsFittedRenderCoords,l=this._planeWorldCoords,p=this._centroidRenderCoords;Object(D.a)(o,p),n.worldUpAtPosition(p,this._worldUp),n.worldBasisAtPosition(p,0,this._worldTangent),Object(d.r)(p,this._worldUp,i,this._worldUp,s),Object(d.r)(p,this._worldTangent,i,this._worldTangent,s),a.length>2&&function(e,t){if(e.length<3)throw new Error("need at least 3 points to fit a plane");Object(P.k)(e[0],e[1],e[2],t)}(a,l),this.fittingMode=this._selectFittingMode(l,a,this._worldUp,r);let u=0;if("horizontal"===this.fittingMode){let e=-1/0;o.forEach(((t,i)=>{const s=n.getAltitude(o[i]);s>e&&(e=s,u=i)}))}const m=a[u];let j=l,O=this._worldTangent;"horizontal"===this.fittingMode?j=this._worldUp:"vertical"===this.fittingMode&&(j=this._tempVec3,O=this._worldUp,Object(P.g)(l,this._worldUp,j)),Object(_.m)(this._frame[2],j),Object(P.g)(O,j,this._frame[0]),Object(_.i)(this._frame[1],this._frame[0],this._frame[2]),Object(_.u)(this._frame[1],this._frame[1]);const f=this._tempVec3,y=this._tempU,v=this._tempV;for(let g=0;g<this._length;++g){const e=h[g],t=c[g];Object(_.l)(f,a[g],m),Object(b.r)(e,Object(_.j)(this._frame[0],f),Object(_.j)(this._frame[1],f)),Object(_.g)(y,this._frame[0],e[0]),Object(_.g)(v,this._frame[1],e[1]),Object(_.h)(f,y,v),Object(_.h)(f,f,m),Object(d.z)(f,s,t,i)}this.perimeterLength=this._length>0?new g.a(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,Object(D.a)(c,this.areaCentroidRenderCoords),Object(d.z)(this.areaCentroidRenderCoords,i,this.areaCentroidWorldCoords,s),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new g.a(t.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const t=e.renderCoordsHelper,i=this.positionsSpherical,s=this.positionsStereographic,r=this._tempVec3,n=function(e,t=null,i=!0){const s=(e,t)=>{if(0===t[0]&&0===t[1]&&0===t[2])return!1;for(let i=0;i<e.length;++i)if(Object(_.j)(t,e[i])<-1e-6)return!1;return!0};if(0===e.length)return!1;if(1===e.length)return t&&Object(_.m)(t,e[0]),!0;Object(_.y)(G,0,0,0);for(let r=0;r<e.length;++r)Object(_.h)(G,G,e[r]);if(Object(_.t)(G,G),s(e,G))return t&&Object(_.m)(t,G),!0;if(!i)return!1;for(let r=0;r<e.length;++r)for(let i=0;i<e.length;++i)if(r!==i&&(Object(_.i)(G,e[r],e[i]),Object(_.t)(G,G),s(e,G)))return t&&Object(_.m)(t,G),!0;return!1}(i,r);if(!n)return void(this.geodesicArea=null);const a=this._tempU,o=this._tempV;Object(P.o)(r,a,o);for(let h=0;h<this._length;++h){const e=Object(_.j)(i[h],a),t=Object(_.j)(i[h],o),n=Object(_.j)(i[h],r);Object(b.r)(s[h],e/n,t/n)}Object(_.g)(r,r,Object(p.e)(e.spatialReference).radius),t.toRenderCoords(r,Object(p.g)(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=n&&0===this.geodesicIntersectingSegments.size?new g.a(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let i=0;for(let s=0;s<this._length;++s)i+=t[s]=Object(b.d)(e[s],e[(s+1)%this._length]);return i}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let i=0;i<this._length;++i)for(let s=i+2;s<this._length;++s){if((s+1)%this._length===i)continue;const r=e[i],n=e[(i+1)%this._length],a=e[s],o=e[(s+1)%this._length];Object(v.d)(r,n,a,o)&&(t.add(i),t.add(s))}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=T(e,2),i=this.triangleIndices=new Uint32Array(Object(m.a)(t,[],2));let s=0;for(let r=0;r<i.length;r+=3)s+=x(e[i[r]],e[i[r+1]],e[i[r+2]]);return s}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let i=0;i<this._length;++i)for(let s=i+2;s<this._length;++s){if((s+1)%this._length===i)continue;const r=e[i],n=e[(i+1)%this._length],a=e[s],o=e[(s+1)%this._length];Object(v.d)(r,n,a,o)&&(t.add(i),t.add(s))}}_computeGeodesicArea(){const e=this.positionsGeographic,t=T(this.positionsStereographic,2),i=this.geodesicTriangleIndices=new Uint32Array(Object(m.a)(t,[],2));let s=0;for(let r=0;r<i.length;r+=3)s+=V(e[i[r]],e[i[r+1]],e[i[r+2]],y.a.WGS84);return s}_selectFittingMode(e,t,i,s){const r=t.map((t=>Math.abs(function(e,t){return Object(_.j)(e,t)+e[3]}(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);!function(e,t){const i=t.center;Object(_.y)(i,0,0,0);for(let r=0;r<e.length;++r)Object(_.h)(i,i,e[r]);Object(_.g)(i,i,1/e.length);let s=0;for(let r=0;r<e.length;++r)s=Math.max(s,Object(_.n)(i,e[r]));t.radius=Math.sqrt(s)}(t,this._tempSphere);const n=r/(2*this._tempSphere.radius),a=n<s.maxRelativeErrorCoplanar,o=n<s.maxRelativeErrorAlmostCoplanar;let h="horizontal";return a?h="oblique":o&&(h=Math.abs(Object(_.j)(i,e))>Math.cos(Object(u.g)(s.verticalAngleThreshold))?"horizontal":"vertical"),h}}function T(e,t){const i=new Float64Array(e.length*t);for(let s=0;s<e.length;++s){const r=e[s];for(let e=0;e<t;++e)i[s*t+e]=r[e]}return i}var I=i(903);let k=class extends c.a{constructor(e){super(e),this._handles=new l.a}initialize(){const e=this.view.spatialReference,t=Object(p.g)(e),i=t===p.a?p.d:t,s=!e||Object(d.b)(e,i)?i:e,r=new I.a(s);this._measurementDataManager=new E(this.view,r),this._handles.add(this.layerViewData.path.on("change",(()=>this._update()))),this._update()}destroy(){this._handles=Object(r.e)(this._handles)}_update(){const e=this.layerViewData;this._measurementDataManager.update(e.path,this.view,e.validMeasurement,{maxRelativeErrorCoplanar:.005,maxRelativeErrorAlmostCoplanar:.01,verticalAngleThreshold:80});const t=this._measurementDataManager.getData();this._set("measurementData",t),e.measurementData=t}};Object(s.a)([Object(n.b)({constructOnly:!0})],k.prototype,"view",void 0),Object(s.a)([Object(n.b)({constructOnly:!0})],k.prototype,"analysis",void 0),Object(s.a)([Object(n.b)({readOnly:!0})],k.prototype,"measurementData",void 0),Object(s.a)([Object(n.b)({constructOnly:!0})],k.prototype,"layerViewData",void 0),k=Object(s.a)([Object(a.a)("esri.views.3d.layers.analysis.AreaMeasurement.AreaMeasurementController")],k);i(113);var q=i(68),U=i(23),W=i(40),F=i(41),H=i(43);const Z=Object(j.b)();class B{constructor(e,t){this.spatialReference=e,this.viewingMode=t,this._unnormalizationInfo=J(e,t)}tag(e){return e}createNew(){return this.tag(Object(j.b)())}fromPoint(e){return this.tag(Object(j.f)(e.x,e.y))}fromArray(e){return this.tag(Object(j.f)(e[0],e[1]))}toArray(e){return[e[0],e[1]]}clone(e){return this.tag(Object(j.e)(e))}copy(e,t){return Object(b.c)(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],t.hasZ=!1,t.hasM=!1,t.spatialReference=this.spatialReference,t}createPoint(e){return new F.a({x:e[0],y:e[1],z:void 0,m:void 0,spatialReference:this.spatialReference})}createPointFromArray(e){return new F.a({x:e[0],y:e[1],z:void 0,m:void 0,spatialReference:this.spatialReference})}createDehydratedPoint(e){return{x:e[0],y:e[1],z:void 0,m:void 0,hasZ:!1,hasM:!1,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,i,s){return Object(b.m)(s,e,t,i)}addDelta(e,t,i){e[0]+=t,e[1]+=i}scale(e,t,i,s){const r=Object(b.a)(Z,e,t),n=Object(b.b)(Z,i,Object(b.h)(i,r));Object(b.p)(e,e,n,s-1)}rotate(e,t,i){Object(b.q)(e,e,t,i)}pointToArray(e){return[e.x,e.y]}getZ(e,t){return t}hasZ(){return!1}getM(e,t){return t}hasM(){return!1}unnormalize(e){$(e,this._unnormalizationInfo)}fromXYZ(e){return this.tag(Object(j.f)(e[0],e[1]))}toXYZ(e,t=0){return Object(O.g)(e[0],e[1],t)}distance(e,t){return Object(b.d)(e,t)}}class N{constructor(e,t,i){this.valueType=e,this.spatialReference=t,this._unnormalizationInfo=J(t,i)}distance(e,t){return 0===this.valueType?Object(_.o)(e,t):Object(b.d)(e,t)}tag(e){return e}createNew(){return this.tag(Object(O.e)())}fromPoint(e){return this.tag(Object(O.g)(e.x,e.y,0===this.valueType?e.z:e.m))}fromArray(e){return this.tag(Object(O.g)(e[0],e[1],e[2]||0))}toArray(e){return[e[0],e[1],e[2]]}clone(e){return this.tag(Object(O.f)(e))}copy(e,t){return Object(_.m)(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],0===this.valueType?(t.z=e[2],t.hasZ=!0,t.hasM=!1):(t.m=e[2],t.hasZ=!1,t.hasM=!0),t.spatialReference=this.spatialReference,t}createPoint(e){return new F.a({x:e[0],y:e[1],z:0===this.valueType?e[2]:void 0,m:1===this.valueType?e[2]:void 0,spatialReference:this.spatialReference})}createPointFromArray(e){return new F.a({x:e[0],y:e[1],z:0===this.valueType?e[2]:void 0,m:1===this.valueType?e[2]:void 0,spatialReference:this.spatialReference})}createDehydratedPoint(e){const t=0===this.valueType,i=1===this.valueType;return{x:e[0],y:e[1],z:t?e[2]:void 0,m:i?e[2]:void 0,hasZ:t,hasM:i,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,i,s){return Object(_.k)(s,e,t,i)}addDelta(e,t,i,s){e[0]+=t,e[1]+=i,0===this.valueType&&(e[2]+=s)}scale(e,t,i,s){const r=Object(b.a)(Z,e,t),n=Object(b.b)(Z,i,Object(b.h)(i,r));Object(b.p)(e,e,n,s-1)}rotate(e,t,i){Object(b.q)(e,e,t,i)}pointToArray(e){return 0===this.valueType?[e.x,e.y,e.z]:[e.x,e.y,e.m]}getZ(e,t){return 0===this.valueType?e[2]:t}hasZ(){return 0===this.valueType}getM(e,t){return 1===this.valueType?e[2]:t}hasM(){return 1===this.valueType}unnormalize(e){$(e,this._unnormalizationInfo)}fromXYZ(e,t=0,i=0){return this.tag(Object(O.g)(e[0],e[1],0===this.valueType?e.length>2?e[2]:t:i))}toXYZ(e,t=0){return this.tag(Object(O.g)(e[0],e[1],0===this.valueType?e[2]:t))}}class X{constructor(e,t){this.spatialReference=e,this._unnormalizationInfo=J(e,t)}distance(e,t){return Object(_.o)(e,t)}tag(e){return e}createNew(){return this.tag(Object(f.e)())}fromPoint(e){return this.tag(Object(f.g)(e.x,e.y,e.z,e.m))}fromArray(e){return this.tag(Object(f.g)(e[0],e[1],e[2]||0,e[3]||0))}toArray(e){return[e[0],e[1],e[2],e[3]]}clone(e){return this.tag(Object(f.d)(e))}copy(e,t){return Object(W.c)(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.hasZ=!0,t.hasM=!0,t.spatialReference=this.spatialReference,t}createPoint(e){return new F.a({x:e[0],y:e[1],z:e[2],m:e[3],spatialReference:this.spatialReference})}createPointFromArray(e){return new F.a({x:e[0],y:e[1],z:e[2],m:e[3],spatialReference:this.spatialReference})}createDehydratedPoint(e){return{x:e[0],y:e[1],z:e[2],m:e[3],hasZ:!0,hasM:!0,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,i,s){return Object(W.j)(s,e,t,i)}addDelta(e,t,i,s){e[0]+=t,e[1]+=i,e[2]+=s}scale(e,t,i,s){const r=Object(b.a)(Z,e,t),n=Object(b.b)(Z,i,Object(b.h)(i,r));Object(b.p)(e,e,n,s-1)}rotate(e,t,i){Object(b.q)(e,e,t,i)}pointToArray(e){return[e.x,e.y,e.z,e.m]}getZ(e){return e[2]}hasZ(){return!0}getM(e){return e[3]}hasM(){return!0}unnormalize(e){$(e,this._unnormalizationInfo)}fromXYZ(e,t=0,i=0){return this.tag(Object(f.g)(e[0],e[1],e.length>2?e[2]:t,i))}toXYZ(e){return Object(O.g)(e[0],e[1],e[2])}}function Y(e,t,i,s){return e&&t?new X(i,s):t?new N(1,i,s):e?new N(0,i,s):new B(i,s)}function $(e,t){if(!t.supported)return;let i=1/0,s=-1/0;const r=t.upperBoundX-t.lowerBoundX;e.forEach((e=>{let n=e.pos[0];for(;n<t.lowerBoundX;)n+=r;for(;n>t.upperBoundX;)n-=r;i=Math.min(i,n),s=Math.max(s,n),e.pos[0]=n}));const n=s-i;r-n<n&&e.forEach((e=>{e.pos[0]<0&&(e.pos[0]+=r)}))}function J(e,t){const i=Object(H.d)(e);return"global"===t&&i?{supported:!0,lowerBoundX:i.valid[0],upperBoundX:i.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}var K=i(87),Q=i(166);class ee{constructor(e){this.left=null,this.right=null,this.type="vertex",this.index=null,this.component=e}get pos(){return this._pos}set pos(e){this._pos=e,this.component.unnormalizeVertexPositions()}}class te{constructor(e,t,i){this.type="edge",this.component=e,this.left=t,this.right=i,t.right=this,i.left=this}}class ie{constructor(e){this.vertices=[],this.edges=[],this.data=e}unnormalizeVertexPositions(){this.vertices.length<=1||this.data.coordinateHelper.unnormalize(this.vertices)}updateVertexIndex(e,t){if(0===this.vertices.length)return;const i=this.vertices[0];let s=null,r=e,n=t;do{s=r,s.index=n++,r=s.right?s.right.right:null}while(null!=r&&r!==i);s.left&&s!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(s),this.vertices.length-1)}getFirstVertex(){return 0===this.vertices.length?null:this.vertices[0]}getLastVertex(){return 0===this.vertices.length?null:this.vertices[this.vertices.length-1]}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].left}swapVertices(e,t){const i=this.vertices[e];this.vertices[e]=this.vertices[t],this.vertices[t]=i}iterateVertices(e){if(0===this.vertices.length)return;const t=this.vertices[0];let i=t;do{e(i,i.index),i=Object(r.j)(i.right)?i.right.right:null}while(i!==t&&null!=i)}}class se extends q.a{constructor(e){super(),this.coordinateHelper=e,this.undoStack=[],this.redoStack=[],this.components=[]}apply(e,t=1){return 0!==t&&!Object(r.i)(this.lastOperation)&&this.lastOperation.accumulate(e)||(e.apply(),this.undoStack.push(e),this.redoStack=[]),e}undo(){if(this.undoStack.length>0){const e=this.undoStack.pop();return e.undo(),this.redoStack.push(e),e}return null}get canUndo(){return this.undoStack.length>0}get lastOperation(){return this.undoStack.length>0?this.undoStack[this.undoStack.length-1]:null}redo(){if(this.redoStack.length>0){const e=this.redoStack.pop();return e.apply(),this.undoStack.push(e),e}return null}get canRedo(){return this.redoStack.length>0}toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.createPoint(this.components[0].vertices[0].pos)}toPolyline(){const e=[],t=this.coordinateHelper.toArray;return this.components.forEach(((i,s)=>{const r=[];let n=i.vertices.find((e=>null==e.left));const a=n;do{r.push(t(n.pos)),n=n.right?n.right.right:null}while(n&&n!==a);e.push(r)})),new Q.a({paths:e,spatialReference:this.coordinateHelper.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}toPolygon(){const e=[],t=this.coordinateHelper.toArray;return this.components.forEach(((i,s)=>{const n=[],a=i.vertices[0];let o=a;const h=o;do{n.push(t(o.pos)),o=Object(r.j)(o.right)?o.right.right:null}while(o&&o!==h);i.isClosed()&&n.push(t(a.pos)),e.push(n)})),new L.a({rings:e,spatialReference:this.coordinateHelper.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(e,t){const i=Y(e.hasZ,e.hasM,e.spatialReference,t),s=new se(i);switch(e.type){case"polygon":{const t=e.rings;for(let e=0;e<t.length;++e){const r=t[e],n=new ie(s),a=r.length>2&&Object(K.e)(r[0],r[r.length-1]),o=a?r.length-1:r.length;for(let e=0;e<o;++e){const t=i.fromArray(r[e]),s=new ee(n);n.vertices.push(s),s.pos=t,s.index=e}const h=n.vertices.length-1;for(let e=0;e<h;++e){const t=n.vertices[e],i=n.vertices[e+1],s=new te(n,t,i);n.edges.push(s)}if(a){const e=new te(n,n.vertices[n.vertices.length-1],n.vertices[0]);n.edges.push(e)}s.components.push(n)}}break;case"polyline":for(const t of e.paths){const e=new ie(s),r=t.length;for(let s=0;s<r;++s){const r=i.fromArray(t[s]),n=new ee(e);e.vertices.push(n),n.pos=r,n.index=s}const n=e.vertices.length-1;for(let t=0;t<n;++t){const i=e.vertices[t],s=e.vertices[t+1],r=new te(e,i,s);e.edges.push(r)}s.components.push(e)}break;case"point":{const t=new ie(s),i=new ee(t);i.index=0,i.pos=s.coordinateHelper.fromPoint(e),t.vertices.push(i),s.components.push(t)}}return s}}class re{constructor(e,t,i){this.editGeometry=e,this.component=t,this.pos=i,this.addedVertex=null,this.originalEdge=null,this.left=null,this.right=null}apply(){let e="redo";Object(r.i)(this.addedVertex)&&(e="apply",this.addedVertex=new ee(this.component));const t=this.component.getLastVertex();if(Object(r.i)(t))this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,this.addedVertex.index=0;else{let e=null;t.right&&(this.originalEdge=t.right,e=this.originalEdge.right,this.component.edges.splice(this.component.edges.indexOf(this.originalEdge),1)),this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,Object(r.i)(this.left)&&(this.left=new te(this.component,t,this.addedVertex)),this.component.edges.push(this.left),t.right=this.left,Object(r.j)(this.originalEdge)&&Object(r.j)(e)&&(Object(r.i)(this.right)&&(this.right=new te(this.component,this.addedVertex,e)),this.component.edges.push(this.right),e.left=this.right),this.component.updateVertexIndex(this.addedVertex,t.index+1)}const i={addedVertices:[this.addedVertex],operation:e};this.editGeometry.emit("change",i)}undo(){if(Object(r.i)(this.addedVertex))return null;this.component.vertices.splice(this.component.vertices.indexOf(this.addedVertex),1),Object(r.j)(this.left)&&(this.component.edges.splice(this.component.edges.indexOf(this.left),1),this.left.left.right=null),Object(r.j)(this.right)&&(this.component.edges.splice(this.component.edges.indexOf(this.right),1),this.right.right.left=null),Object(r.j)(this.originalEdge)&&(this.component.edges.push(this.originalEdge),this.originalEdge.left.right=this.originalEdge,this.originalEdge.right.left=this.originalEdge),Object(r.j)(this.left)?this.component.updateVertexIndex(this.left.left,this.left.left.index):this.component.updateVertexIndex(this.addedVertex,0);const e={removedVertices:[this.addedVertex],operation:"undo"};this.editGeometry.emit("change",e)}accumulate(){return!1}}class ne{constructor(e,t,i){this.editGeometry=e,this.vertex=t,this.pos=i}apply(){const e=Object(r.i)(this.originalPosition);e&&(this.originalPosition=this.vertex.pos),this._apply(e?"apply":"redo")}undo(){this.vertex.pos=Object(r.s)(this.originalPosition);const e={updatedVertices:[this.vertex],operation:"undo"};this.editGeometry.emit("change",e)}accumulate(e){return e instanceof ne&&e.vertex===this.vertex&&(this.pos=e.pos,this._apply("apply"),!0)}_apply(e){this.vertex.pos=this.pos,this.editGeometry.components.forEach((e=>e.unnormalizeVertexPositions()));const t={updatedVertices:[this.vertex],operation:e};this.editGeometry.emit("change",t)}}class ae{constructor(e,t){this.editGeometry=e,this.component=t,this.createdEdge=null}apply(){let e="redo";if(Object(r.i)(this.createdEdge)){e="apply";const t=this.component.getFirstVertex(),i=this.component.getLastVertex();if(this.component.isClosed()||this.component.vertices.length<3||Object(r.i)(t)||Object(r.i)(i))return;this.createdEdge=new te(this.component,i,t)}this.createdEdge.left.right=this.createdEdge,this.createdEdge.right.left=this.createdEdge,this.component.edges.push(this.createdEdge);const t={operation:e};this.editGeometry.emit("change",t)}undo(){if(Object(r.i)(this.createdEdge))return;this.component.edges.splice(this.component.edges.indexOf(this.createdEdge),1),this.createdEdge.left.right=null,this.createdEdge.right.left=null;this.editGeometry.emit("change",{operation:"undo"})}accumulate(){return!1}}let oe=class extends q.a.EventedAccessor{constructor(e={}){super(e),this._handles=new l.a,this._version=0,this._internalGeometryChange=!1}set areaMeasurement(e){this._set("areaMeasurement",e),Object(r.j)(e)&&Object(r.j)(this.view)&&this._initialize(e,this.view)}set view(e){this._set("view",e),Object(r.j)(e)&&Object(r.j)(this.areaMeasurement)&&this._initialize(this.areaMeasurement,e)}get initialized(){return Object(r.j)(this.areaMeasurement)&&Object(r.j)(this.view)}get version(){return this._version}get isValidPolygon(){return this.initialized&&this._editGeometry.components.length>0&&this._editGeometry.components[0].isClosed()}_initialize(e,t){this._handles.removeAll(),this._handles.add(Object(U.a)(e,"geometry",(()=>this._updateEditGeometryFromModelGeometry(e,t)),!0)),this._makeDirty(!0)}_makeDirty(e=!1){this.notifyChange("isValidPolygon"),this.notifyChange("initialized"),e&&this.notifyChange("numVertices")}_updateEditGeometryFromModelGeometry(e,t){this._version++,this._internalGeometryChange||(this._handles.remove("EditGeometry"),this._editGeometry=Object(r.j)(e.geometry)?se.fromGeometry(e.geometry,t.viewingMode):new se(Y(!0,!1,t.spatialReference,t.viewingMode)),this._makeDirty(!0),this.emit("change",{type:"change"}),this._handles.add(this._editGeometry.on("change",(t=>{this._makeDirty(null!=t.addedVertices||null!=t.removedVertices),this._internalGeometryChange=!0,e.geometry=this.numVertices>0?this._editGeometry.toPolygon():null,this._internalGeometryChange=!1})),"EditGeometry"))}get vertices(){const e=[];return this.forEachVertex((t=>{e.push(t)})),e}get numVertices(){return this.initialized&&this._editGeometry.components.length>0?this._editGeometry.components[0].vertices.length:0}get lastPoint(){if(this.initialized&&this._editGeometry.components.length>0){const e=this._editGeometry.components[0].getLastVertex();if(Object(r.j)(e))return this._editGeometry.coordinateHelper.createPoint(e.pos)}return null}getVertex(e){if(!this.initialized||0===this._editGeometry.components.length||0===this._editGeometry.components[0].vertices.length)return null;const t=this._editGeometry.components[0].vertices[0];let i=t;do{if(i.index===e)return i;i=i.right.right}while(i!==t&&null!=i);return null}getVertexPositionAsPoint(e){return this._editGeometry.coordinateHelper.createPoint(e.pos)}getVertexPositionAsPointFromIndex(e){return this._editGeometry.coordinateHelper.createPoint(this.getVertex(e).pos)}forEachVertex(e){this.initialized&&this._editGeometry.components.length>0&&this._editGeometry.components[0].iterateVertices(e)}forEachVertexPosition(e){const t=this._editGeometry.coordinateHelper;this.forEachVertex(((i,s)=>{t.toPoint(i.pos,he),e(he,s)}))}clear(){Object(r.j)(this.areaMeasurement)&&(this.areaMeasurement.geometry=null)}add(e){if(!this.initialized)return null;0===this._editGeometry.components.length&&this._editGeometry.components.push(new ie(this._editGeometry));const t=new re(this._editGeometry,this._editGeometry.components[0],this._editGeometry.coordinateHelper.fromPoint(e));return this._editGeometry.apply(t),this.emit("change",{type:"change"}),t}close(){if(!this.initialized)return null;if(0===this._editGeometry.components.length)return null;const e=this._editGeometry.components[0],t=new ae(this._editGeometry,e);return this._editGeometry.apply(t),this.emit("change",{type:"change"}),t}ensureContains(e,t=""){let i=!1;if(this._editGeometry.components.forEach((t=>{t.iterateVertices((t=>{t===e&&(i=!0)}))})),!i)throw new Error(`vertex doesnt exist ${t}`);return i}setVertexPosition(e,t){if(!this.initialized)return null;const i=new ne(this._editGeometry,e,this._editGeometry.coordinateHelper.fromPoint(t));return this._editGeometry.apply(i),this.emit("change",{type:"change"}),i}equals(e){if(this.numVertices!==e.numVertices)return!1;let t=!0;return this.forEachVertexPosition(((i,s)=>{const r=e.getVertexPositionAsPointFromIndex(s);i.equals(r)||(t=!1)})),!!t}};Object(s.a)([Object(n.b)({value:null})],oe.prototype,"areaMeasurement",null),Object(s.a)([Object(n.b)({value:null})],oe.prototype,"view",null),Object(s.a)([Object(n.b)()],oe.prototype,"isValidPolygon",null),Object(s.a)([Object(n.b)()],oe.prototype,"numVertices",null),oe=Object(s.a)([Object(a.a)("esri.views.3d.interactive.graphics.AreaMeasurement3D.AreaMeasurement3DPathHelper")],oe);const he=new F.a;let ce=class extends c.a{constructor(){super(...arguments),this.measurementData=null,this.unitNormalizer=new I.a,this.path=new oe,this.lastDraggedVertex=null}destroy(){this.measurementData=null,this.path=Object(r.e)(this.path)}get validMeasurement(){return this.path.isValidPolygon}};Object(s.a)([Object(n.b)()],ce.prototype,"measurementData",void 0),Object(s.a)([Object(n.b)()],ce.prototype,"validMeasurement",null),Object(s.a)([Object(n.b)()],ce.prototype,"unitNormalizer",void 0),Object(s.a)([Object(n.b)()],ce.prototype,"path",void 0),Object(s.a)([Object(n.b)()],ce.prototype,"lastDraggedVertex",void 0),Object(s.a)([Object(n.b)()],ce.prototype,"cursorPoint",void 0),ce=Object(s.a)([Object(a.a)("esri.views.3d.layers.analysis.AreaMeasurement3D.AreaMeasurementLayerViewData")],ce);i(340);var le,de,pe=i(947),ue=i(54),ge=i(289),me=i(16),be=i(20);(de=le||(le={})).boundingSphere=function(e,t){const i=t.center;Object(_.y)(i,0,0,0);for(let r=0;r<e.length;++r)Object(_.h)(i,i,e[r]);Object(_.g)(i,i,1/e.length);let s=0;for(let r=0;r<e.length;++r)s=Math.max(s,Object(_.n)(i,e[r]));t.radius=Math.sqrt(s)},de.bestFitPlane=function(e,t){if(e.length<3)throw new Error("need at least 3 points to fit a plane");Object(P.k)(e[0],e[1],e[2],t)},de.planePointDistance=function(e,t){return Object(_.j)(e,t)+e[3]},de.segmentLengthEuclidean=function(e,t,i){return Object(d.u)(e,je,i)&&Object(d.u)(t,_e,i)?Object(_.o)(je,_e):0},de.segmentLengthGeodesic=function(e,t){if(!Object(d.v)(e,je)||!Object(d.v)(t,_e))return 0;const i={distance:null};return Object(S.b)(i,[je[0],je[1]],[_e[0],_e[1]]),i.distance},de.segmentLengthGeodesicVector=function(e,t,i){const s={distance:null};return Object(S.b)(s,[e[0],e[1]],[t[0],t[1]],i),s.distance},de.triangleAreaEuclidean=function(e,t,i){const s=t[0]-e[0],r=t[1]-e[1],n=i[0]-e[0],a=i[1]-e[1];return.5*Math.abs(s*a-r*n)},de.triangleAreaGeodesic=function(e,t,i,s){const r=fe;return Object(d.A)(e,s,je)&&Object(d.A)(t,s,_e)&&Object(d.A)(i,s,Oe)?(r.setPoint(0,0,je),r.setPoint(0,1,_e),r.setPoint(0,2,Oe),Math.abs(Object(w.geodesicArea)(r,"square-meters"))):0},de.tangentFrame=function(e,t,i){Math.abs(e[0])>Math.abs(e[1])?Object(_.y)(t,0,1,0):Object(_.y)(t,1,0,0),Object(_.i)(i,e,t),Object(_.t)(t,t),Object(_.i)(t,i,e),Object(_.t)(i,i)},de.fitHemisphere=function(e,t=null,i=!0){const s=(e,t)=>{if(0===t[0]&&0===t[1]&&0===t[2])return!1;for(let i=0;i<e.length;++i)if(Object(_.j)(t,e[i])<-1e-6)return!1;return!0};if(0===e.length)return!1;if(1===e.length)return t&&Object(_.m)(t,e[0]),!0;Object(_.y)(ye,0,0,0);for(let r=0;r<e.length;++r)Object(_.h)(ye,ye,e[r]);if(Object(_.t)(ye,ye),s(e,ye))return t&&Object(_.m)(t,ye),!0;if(!i)return!1;for(let r=0;r<e.length;++r)for(let i=0;i<e.length;++i)if(r!==i&&(Object(_.i)(ye,e[r],e[i]),Object(_.t)(ye,ye),s(e,ye)))return t&&Object(_.m)(t,ye),!0;return!1},de.compareSets=function(e,t){if(e===t)return!0;if(e.size!==t.size)return!1;for(let i=0;i<e.size;++i)if(!t.has(e[i]))return!1;return!0};const je=Object(O.e)(),_e=Object(O.e)(),Oe=Object(O.e)(),fe=new L.a({rings:[[je,_e,Oe]],spatialReference:y.a.WGS84}),ye=Object(O.e)();var ve=le,we=i(948),Le=i(963),Se=i(784),Pe=i(742),Ce=i(100),xe=i(184),Ve=i(103),Me=i(231),Ae=i(88),ze=i(98),Re=i(92),Ge=i(77),De=i(82),Ee=i(15),Te=i(62),Ie=i(75),ke=i(74),qe=i(905),Ue=i(30);class We extends De.a{initializeProgram(e){const t=We.shader.get(),i=this.configuration,s=t.build({OITEnabled:0===i.transparencyPassType,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new ke.a(e.rctx,s,Te.a)}bindPass(e,t){Object(Re.c)(this.program,t.camera.projectionMatrix),this.program.setUniform2fv("size",e.size),this.program.setUniform4fv("color1",e.color1),this.program.setUniform4fv("color2",e.color2),t.multipassTerrainEnabled&&(this.program.setUniform2fv("cameraNearFar",t.camera.nearFar),this.program.setUniform2fv("inverseViewport",t.inverseViewport),Object(ze.a)(this.program,t))}bindDraw(e){Object(Re.d)(this.program,e)}setPipelineState(e){const t=this.configuration,i=3===e,s=2===e;return Object(Ue.g)({blending:t.transparent?i?He:Object(Ie.a)(e):null,depthTest:{func:Object(Ie.b)(e)},depthWrite:i?t.writeDepth&&Ue.e:Object(Ie.c)(e),colorWrite:Ue.d,polygonOffset:i||s?t.polygonOffset&&Fe:{factor:-1,units:-25}})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}}We.shader=new Ge.a(qe.a,(()=>i.e(186).then(i.bind(null,1147))));const Fe={factor:0,units:-25},He=Object(Ue.h)(770,1,771,771);class Ze extends Ee.a{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}Object(s.a)([Object(Ee.b)()],Ze.prototype,"transparent",void 0),Object(s.a)([Object(Ee.b)()],Ze.prototype,"writeDepth",void 0),Object(s.a)([Object(Ee.b)()],Ze.prototype,"polygonOffset",void 0),Object(s.a)([Object(Ee.b)({count:4})],Ze.prototype,"transparencyPassType",void 0),Object(s.a)([Object(Ee.b)()],Ze.prototype,"multipassTerrainEnabled",void 0),Object(s.a)([Object(Ee.b)()],Ze.prototype,"cullAboveGround",void 0);class Be extends Ve.a{constructor(e){super(e,Xe),this.techniqueConfig=new Ze}dispose(){}getPassParameters(){return this.params}getTechniqueConfig(e){return this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.transparencyPassType=e?e.transparencyPassType:3,this.techniqueConfig.multipassTerrainEnabled=!!e&&e.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!e&&e.cullAboveGround,this.techniqueConfig}intersect(e,t,i,s,r,n,a){return Object(Ae.i)(e,t,s,r,n,void 0,a)}getGLMaterial(e){return 0===e.output||7===e.output?new Ne(e):void 0}createBufferWriter(){return new Me.a(Me.d)}}class Ne extends xe.a{constructor(e){super(e),this.updateParameters()}updateParameters(e){this._technique=this._techniqueRep.releaseAndAcquire(We,this._material.getTechniqueConfig(e),this._technique)}beginSlot(e){let t=3;return this._technique.configuration.transparent&&(t=this._technique.configuration.writeDepth?5:8),e===t}ensureParameters(e){this.updateParameters(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}}const Xe={size:[1,1],color1:[.75,.75,.75,1],color2:[.5,.5,.5,1],transparent:!1,writeDepth:!0,polygonOffset:!1,...Ve.b};class Ye extends Pe.a{constructor(e){super(e),this._checkerBoardMaterial=null,this._renderOccluded=4,this._geometry=null,this._size=[1,1],this._color1=[1,.5,0,.5],this._color2=[1,1,1,.5],this.applyProps(e)}get renderOccluded(){return this._renderOccluded}set renderOccluded(e){e!==this._renderOccluded&&(this._renderOccluded=e,this.updateMaterial())}get geometry(){return this._geometry}set geometry(e){this._geometry=e,this.geometryChanged()}get size(){return this._size}set size(e){this._size=e,this.updateMaterial()}get color1(){return this._color1}set color1(e){this._color1=e,this.updateMaterial()}get color2(){return this._color2}set color2(e){this._color2=e,this.updateMaterial()}updateMaterial(){Object(r.j)(this._checkerBoardMaterial)&&this._checkerBoardMaterial.setParameterValues({size:this._size,color1:this._color1,color2:this._color2,renderOccluded:this._renderOccluded})}createExternalResources(){this._checkerBoardMaterial=new Be({size:this._size,color1:this._color1,color2:this._color2,transparent:!0,writeDepth:!1,polygonOffset:!0,renderOccluded:4})}destroyExternalResources(){this._checkerBoardMaterial=null}forEachExternalMaterial(e){Object(r.j)(this._checkerBoardMaterial)&&e(this._checkerBoardMaterial)}createGeometries(e){if(Object(r.i)(this._geometry)||Object(r.i)(this._checkerBoardMaterial))return;const t=$e;Object(me.u)(t,this.transform);const i=this._geometry,s=[],n=Object(O.e)();i.position.forEach((e=>{Object(_.l)(n,e,t),s.push(n[0],n[1],n[2])}));const a=[];i.uv.forEach((e=>{a.push(e[0],e[1])}));const o=new Ce.a([["position",{size:3,data:s,exclusive:!0}],["uv0",{size:2,data:a,exclusive:!0}]],[["position",i.triangleIndices],["uv0",i.triangleIndices]]);e.addGeometry(o,this._checkerBoardMaterial)}geometryChanged(){this.recreateGeometry()}}const $e=Object(O.e)();var Je=i(949),Ke=i(461),Qe=i(125),et=i(232);let tt=class extends c.a{constructor(e){super(e),this._handles=new l.a,this._params={...it},this._path=null,this._intersectedPath=null,this._perimeter=null,this._intersectedPerimeter=null,this._projectionLines=null,this._measurementArea=null,this._areaLabel=null,this._pathLengthLabel=null,this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel=null,this._pathSegments=[],this._perimeterSegments=[],this._cursorSegment=null,this._origin=Object(O.e)(),this._originTransform=Object(be.d)(),this._cursorPositionRenderSpace=Object(O.e)(),this.messages=null,this.viewData=st,this.areaLabel=null,this.perimeterLengthLabel=null,this.mode="auto",this.geodesicMeasurementDistanceThreshold=1e5}get visible(){return this.layerView.visible&&!this.layerView.suspended}get testData(){return{labels:{area:this._areaLabel,pathLength:this._pathLengthLabel,cursorSegmentLength:this._cursorSegmentLengthLabel,perimeterLength:this._perimeterLengthLabel}}}initialize(){const e=this.view;this._path=new Se.a({view:e,attached:!0,width:this._params.pathLineWidth,color:this._params.pathLineColor,polygonOffset:!0,renderOccluded:4}),this._intersectedPath=new Se.a({view:e,attached:!0,width:this._params.pathLineWidth,color:this._params.intersectingLineColor,polygonOffset:!0,renderOccluded:4}),this._perimeter=new Se.a({view:e,attached:!0,width:this._params.perimeterLineWidth,color:this._params.perimeterLineColor,polygonOffset:!0,renderOccluded:4}),this._intersectedPerimeter=new Se.a({view:e,attached:!0,width:this._params.perimeterLineWidth,color:this._params.intersectingLineColor,polygonOffset:!0,renderOccluded:4}),this._projectionLines=new Se.a({view:e,attached:!0,width:this._params.projectionLineWidth,color:this._params.projectionLineColor,stipplePattern:Object(Ke.b)(this._params.projectionLineStippleSize),stippleIntegerRepeats:!1,polygonOffset:!0,renderOccluded:4}),this._measurementArea=new Ye({view:e,attached:!0,color1:this._params.areaColor1,color2:this._params.areaColor2}),this._areaLabel=new Le.a({view:this.view,attached:!0,fontSize:16}),this._pathLengthLabel=new Le.a({view:e,attached:!0,fontSize:12}),this._cursorSegmentLengthLabel=new Le.a({view:e,attached:!0,fontSize:12}),this._perimeterLengthLabel=new Le.a({view:e,attached:!0,fontSize:12});const t=this.layerView,i=t.layerViewData;this._handles.add([Object(ge.d)((()=>[this.mode,this.visible,t.unit,i.measurementData,i.cursorPoint]),(()=>this._update())),Object(ge.d)((()=>{var t;return null==(t=e.state)?void 0:t.camera}),(()=>this._updateLabels())),Object(Qe.c)((async()=>this._updateMessageBundle()))]),this._updateMessageBundle()}destroy(){this._measurementArea.destroy(),this._measurementArea=null,this._path.destroy(),this._path=null,this._intersectedPath.destroy(),this._intersectedPath=null,this._perimeter.destroy(),this._perimeter=null,this._intersectedPerimeter.destroy(),this._intersectedPerimeter=null,this._areaLabel.destroy(),this._areaLabel=null,this._pathLengthLabel.destroy(),this._pathLengthLabel=null,this._cursorSegmentLengthLabel.destroy(),this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel.destroy(),this._perimeterLengthLabel=null,this.set("view",null)}async whenMessages(){await Object(U.j)(this,"messages")}_update(){if(this.destroyed)return;const e=this.layerView.layerViewData.measurementData;Object(r.i)(e)||(this._updateViewData(e,this.layerView.layerViewData.path,this.layerView.layerViewData.cursorPoint),this._updateOrigin(),this._updatePathSegments(),this._updatePerimeterSegments(),this._updateArea(),this._updateProjectionLines(),this._updateLabels())}_updateViewData(e,t,i){const s=t.isValidPolygon,n=t.lastPoint,a=Object(r.j)(n)&&Object(r.j)(i)?new g.a(ve.segmentLengthGeodesic(n,i),"meters"):null,o=Object(r.j)(n)&&Object(r.j)(i)?new g.a(e.unitNormalizer.normalizeDistance(ve.segmentLengthEuclidean(n,i,e.unitNormalizer.spatialReference)),"meters"):null;let h;"auto"===this.mode?(h="euclidean",(e.geodesicPathLength?e.geodesicPathLength.value:0)+(!s&&Object(r.j)(a)?a.value:0)>this.geodesicMeasurementDistanceThreshold&&(h="geodesic")):h=this.mode,null==e.geodesicPathLength&&(h="euclidean");const c="geodesic"===h,l=c?e.geodesicArea:e.area;let d=1;if(l){const t=this._toPreferredAreaUnit(l,this.layerView.unit);d=Object(u.o)(Math.sqrt(t.value)/Math.sqrt(300)),d*=Math.sqrt(Object(ue.c)(1,t.unit,"square-meters")),d/=e.unitNormalizer.normalizeDistance(1)}const p={validMeasurement:s,path:t,pathVersion:t.version,cursorPoint:i,measurementData:e,mode:h,positionsGeographic:e.positionsGeographic,positionsRenderCoords:e.positionsRenderCoords,positionsProjected:e.positionsProjectedWorldCoords,positionsFittedRenderCoords:e.positionsFittedRenderCoords,intersectingSegments:c?e.geodesicIntersectingSegments:e.intersectingSegments,triangleIndices:c?e.geodesicTriangleIndices:e.triangleIndices,fittingMode:e.fittingMode,areaCentroid:c?e.geodesicAreaCentroidRenderCoords:e.areaCentroidRenderCoords,pathLengthLabelSegmentIndex:s?0:t.numVertices-2,perimeterLengthLabelSegmentIndex:0,checkerSize:d,geodesicCursorSegmentLength:a,cursorSegmentLength:o};this._set("viewData",p)}_updateOrigin(){const e=this.viewData;Object(we.a)(e.positionsRenderCoords,this._origin),Object(me.i)(this._originTransform),Object(me.t)(this._originTransform,this._originTransform,this._origin),this._measurementArea.transform=this._originTransform,this._projectionLines.transform=this._originTransform}_createSegments(e){const t=this.viewData,i=t.path,s=this.view.renderCoordsHelper.spatialReference,r=t.mode,n=[],a=[],o=[],h=t.validMeasurement?i.numVertices:i.numVertices-1;for(let c=0;c<h;++c){const h=t[e][c],l=t[e][(c+1)%i.numVertices];let d=null;switch(r){case"euclidean":d=new Je.a(h,l);break;case"geodesic":d=new Je.b(h,l,s)}t.intersectingSegments.has(c)?o.push(d):a.push(d),n.push(d)}return{all:n,nonIntersecting:a,intersecting:o}}_updatePathSegments(){const e=this.visible,t=this.viewData,i=this._createSegments("positionsRenderCoords"),s=t.path,n=!s.isValidPolygon,a=t.cursorPoint,o=this.view.renderCoordsHelper,h=o.spatialReference,c=t.mode;if(this._cursorSegment=null,s.numVertices>0&&n&&Object(r.j)(a)&&o.toRenderCoords(a,this._cursorPositionRenderSpace)){const e=t.positionsRenderCoords[s.numVertices-1],r=this._cursorPositionRenderSpace;let n=null;switch(c){case"euclidean":n=new Je.a(e,r);break;case"geodesic":n=new Je.b(e,r,h)}i.nonIntersecting.push(n),this._cursorSegment=n}this._path.setGeometryFromSegments(i.nonIntersecting,this._origin),this._path.visible=e,this._intersectedPath.setGeometryFromSegments(i.intersecting,this._origin),this._intersectedPath.visible=e,this._pathSegments=i.all}_updatePerimeterSegments(){const e=this.visible&&"euclidean"===this.viewData.mode,t=this._createSegments("positionsFittedRenderCoords");this._perimeter.setGeometryFromSegments(t.nonIntersecting,this._origin),this._perimeter.visible=e,this._intersectedPerimeter.setGeometryFromSegments(t.intersecting,this._origin),this._intersectedPerimeter.visible=e,this._perimeterSegments=t.all}_updateArea(){const e=this.viewData;switch(e.mode){case"euclidean":this._updateAreaEuclidean(e);break;case"geodesic":this._updateAreaGeodesic()}}_updateAreaEuclidean(e){const t=this.visible;e.validMeasurement&&0===e.intersectingSegments.size&&e.triangleIndices?(this._measurementArea.geometry={uv:e.positionsProjected,position:e.positionsFittedRenderCoords,triangleIndices:e.triangleIndices},this._measurementArea.size=[e.checkerSize,e.checkerSize],this._measurementArea.visible=t):this._measurementArea.visible=!1}_updateAreaGeodesic(){this._measurementArea.visible=!1}_updateProjectionLines(){const e=this.viewData,t=this.visible,i=e.path,s=e.mode;if(i.numVertices>0&&e.validMeasurement&&"euclidean"===s){const s=[];for(let t=0;t<i.numVertices;++t){const i=Object(O.e)();Object(_.l)(i,e.positionsRenderCoords[t],this._origin);const r=Object(O.e)();Object(_.l)(r,e.positionsFittedRenderCoords[t],this._origin),s.push([i,r])}this._projectionLines.geometry=s,this._projectionLines.visible=t}else this._projectionLines.geometry=null,this._projectionLines.visible=!1}_updateLabels(){if(this.destroyed)return;const e=this.viewData,t=e.path;if(!t)return;const i=e.measurementData,s=e.mode,n=!t.isValidPolygon,a=this.visible,o=this._formatAreaLabel(this.messages,"geodesic"===s?i.geodesicArea:i.area,this.layerView.unit);Object(r.j)(o)?(this._areaLabel.geometry={type:"point",point:e.areaCentroid},this._areaLabel.text=o,this._areaLabel.visible=e.validMeasurement&&0===e.intersectingSegments.size&&a):this._areaLabel.visible=!1,this._set("areaLabel",Object(r.s)(o));const h=this._formatLengthLabel(this.messages,"geodesic"===s?i.geodesicPathLength:i.pathLength,this.layerView.unit);if(Object(r.j)(h)&&e.pathLengthLabelSegmentIndex>=0&&e.pathLengthLabelSegmentIndex<this._pathSegments.length){const i=this._pathSegments[e.pathLengthLabelSegmentIndex],s=Object(r.j)(this._cursorSegment)?this._cursorSegment:rt;this._pathLengthLabel.distance=this._params.labelDistance,this._pathLengthLabel.geometry={type:"corner",left:i,right:s},this._pathLengthLabel.text=h,this._pathLengthLabel.visible=n&&t.numVertices>0&&a}else this._pathLengthLabel.visible=!1;const c="geodesic"===s?e.geodesicCursorSegmentLength:e.cursorSegmentLength;if(Object(r.j)(c)){const e=this._formatLengthLabel(this.messages,c,this.layerView.unit);this._cursorSegmentLengthLabel.distance=this._params.labelDistance,this._cursorSegmentLengthLabel.geometry=Object(r.j)(this._cursorSegment)?{type:"segment",segment:this._cursorSegment,sampleLocation:"end"}:null,this._cursorSegmentLengthLabel.anchor="bottom",this._cursorSegmentLengthLabel.text=Object(r.s)(e),this._cursorSegmentLengthLabel.visible=n&&0!==c.value&&a}else this._cursorSegmentLengthLabel.visible=!1;this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel)&&(this._cursorSegmentLengthLabel.visible=!1),this._pathLengthLabel.overlaps(this._areaLabel)&&(this._pathLengthLabel.visible=!1);const l="geodesic"===e.mode,d=l?i.geodesicPathLength:i.perimeterLength,p=Object(r.s)(null!=d?this._formatLengthLabel(this.messages,d,this.layerView.unit):null);if(this._set("perimeterLengthLabel",Object(r.s)(p)),e.validMeasurement&&0===e.intersectingSegments.size){this._perimeterLengthLabel.distance=this._params.labelDistance,this._perimeterLengthLabel.anchor="top",this._perimeterLengthLabel.text=p,this._perimeterLengthLabel.visible=!0;let t=!0;for(let i=0;i<e.path.numVertices;++i){const s=(e.perimeterLengthLabelSegmentIndex+i)%e.path.numVertices,r=l?this._pathSegments[s]:this._perimeterSegments[s];if(t=!0,this._perimeterLengthLabel.geometry={type:"segment",segment:r,sampleLocation:"center"},!this._perimeterLengthLabel.overlaps(this._areaLabel))break;t=!1}this._perimeterLengthLabel.visible=t&&a}else this._perimeterLengthLabel.visible=!1}_toPreferredAreaUnit(e,t){return e.toUnit(this._preferredAreaUnit(e,t))}_preferredAreaUnit(e,t){switch(t){case"metric":return Object(ue.r)(e.value,e.unit);case"imperial":return Object(ue.o)(e.value,e.unit);default:return t}}_preferredLengthUnit(e,t){const i=this._deriveLengthUnitFromAreaUnit(t);switch(i){case"metric":return Object(ue.s)(e.value,e.unit);case"imperial":return Object(ue.p)(e.value,e.unit);default:return i}}_deriveLengthUnitFromAreaUnit(e){switch(e){case"metric":return"metric";case"imperial":return"imperial";case"square-inches":return"inches";case"square-feet":return"feet";case"square-yards":return"yards";case"square-miles":return"miles";case"square-us-feet":return"us-feet";case"square-millimeters":return"millimeters";case"square-centimeters":return"centimeters";case"square-decimeters":return"decimeters";case"square-meters":return"meters";case"square-kilometers":return"kilometers";case"acres":return"imperial";case"ares":case"hectares":return"metric"}throw new Error("unhandled area unit")}_formatAreaLabel(e,t,i){return e&&t&&Object(pe.b)(e,t,this._preferredAreaUnit(t,i))}_formatLengthLabel(e,t,i){return e&&t&&Object(pe.b)(e,t,this._preferredLengthUnit(t,i))}_updateMessageBundle(){Object(et.a)("esri/core/t9n/Units").then((e=>{this.messages=e,this.view&&this._update()}))}};Object(s.a)([Object(n.b)()],tt.prototype,"view",void 0),Object(s.a)([Object(n.b)()],tt.prototype,"messages",void 0),Object(s.a)([Object(n.b)()],tt.prototype,"analysis",void 0),Object(s.a)([Object(n.b)()],tt.prototype,"viewData",void 0),Object(s.a)([Object(n.b)()],tt.prototype,"layerView",void 0),Object(s.a)([Object(n.b)({readOnly:!0})],tt.prototype,"areaLabel",void 0),Object(s.a)([Object(n.b)({readOnly:!0})],tt.prototype,"perimeterLengthLabel",void 0),Object(s.a)([Object(n.b)()],tt.prototype,"mode",void 0),Object(s.a)([Object(n.b)({readOnly:!0})],tt.prototype,"visible",null),Object(s.a)([Object(n.b)()],tt.prototype,"geodesicMeasurementDistanceThreshold",void 0),tt=Object(s.a)([Object(a.a)("esri.views.3d.layers.analysis.AreaMeasurement.AreaMeasurementView")],tt);const it={laserLineGlowColor:[1,.5,0],laserLineGlowWidth:8,laserLineGlowFalloff:8,laserLineInnerColor:[1,1,1],laserLineInnerWidth:1,laserLineGlobalAlpha:.75,laserLineEnabled:!0,handleColor:[1,.5,0],handleOpacity:.5,handleRadius:5,handleRadiusHovered:10,handleRadiusMouse:10,handleRadiusTouch:25,pathLineColor:[1,.5,0,1],pathLineWidth:3,intersectingLineColor:[1,.2,0,1],perimeterLineColor:[1,.5,0,1],perimeterLineWidth:2,projectionLineColor:[1,.5,0,1],projectionLineWidth:2,projectionLineStippleSize:5,areaColor1:[1,.5,0,.5],areaColor2:[1,1,1,.5],fillColor:[1,.5,0,.5],lineSubdivisions:64,labelDistance:25},st={validMeasurement:!1,path:null,pathVersion:-1,cursorPoint:null,measurementData:null,mode:null,positionsGeographic:null,positionsRenderCoords:null,positionsProjected:null,positionsFittedRenderCoords:null,intersectingSegments:null,triangleIndices:null,fittingMode:null,areaCentroid:null,pathLengthLabelSegmentIndex:null,perimeterLengthLabelSegmentIndex:null,checkerSize:null,geodesicCursorSegmentLength:null,cursorSegmentLength:null},rt=new Je.a(Object(O.e)(),Object(O.e)());var nt=i(562);let at=class extends(Object(h.a)(nt.a)){constructor(e){super(e),this.type="area-measurement-3d",this.layerViewData=new ce,this._userUnit=null}set unit(e){this._userUnit=e}get unit(){return Object(r.t)(this._userUnit,this._defaultUnit)}get result(){if(Object(r.j)(this.layerViewData.measurementData)){const e=this.layerViewData.measurementData;return{area:e.area,geodesicArea:e.geodesicArea,pathLength:e.pathLength,geodesicPathLength:e.geodesicPathLength,perimeterLength:e.perimeterLength}}return{area:null,geodesicArea:null,pathLength:null,geodesicPathLength:null,perimeterLength:null}}initialize(){this.layerViewData.path.view=this.view,this.layerViewData.path.areaMeasurement=this.layer,this.analysisView=new tt({view:this.view,analysis:this.layer,layerView:this}),this.analysisController=new k({view:this.view,analysis:this.layer,layerViewData:this.layerViewData})}destroy(){this.analysisController=Object(r.e)(this.analysisController),this.analysisView=Object(r.e)(this.analysisView)}get testData(){return{view:this.analysisView,controller:this.analysisController}}};Object(s.a)([Object(n.b)()],at.prototype,"type",void 0),Object(s.a)([Object(n.b)()],at.prototype,"analysisView",void 0),Object(s.a)([Object(n.b)()],at.prototype,"analysisController",void 0),Object(s.a)([Object(n.b)()],at.prototype,"unit",null),Object(s.a)([Object(n.b)()],at.prototype,"layer",void 0),Object(s.a)([Object(n.b)()],at.prototype,"result",null),Object(s.a)([Object(n.b)()],at.prototype,"layerViewData",void 0),Object(s.a)([Object(n.b)(o.a)],at.prototype,"_defaultUnit",void 0),Object(s.a)([Object(n.b)()],at.prototype,"_userUnit",void 0),at=Object(s.a)([Object(a.a)("esri.views.3d.layers.AreaMeasurementLayerView3D")],at);var ot=at;t.default=ot},905:function(e,t,i){"use strict";i.d(t,"a",(function(){return c})),i.d(t,"b",(function(){return h}));var s=i(107),r=i(98),n=i(167),a=i(6),o=i(73);function h(e){const t=new o.a;return t.extensions.add("GL_OES_standard_derivatives"),t.attributes.add("position","vec3"),t.attributes.add("uv0","vec2"),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.varyings.add("vUV","vec2"),e.multipassTerrainEnabled&&t.varyings.add("depth","float"),t.vertex.code.add(a.a`
    void main(void) {
      vUV = uv0;
      ${e.multipassTerrainEnabled?"depth = (view * vec4(position, 1.0)).z;":""}
      gl_Position = proj * view * vec4(position, 1.0);
    }
  `),e.multipassTerrainEnabled&&(t.fragment.include(s.a),t.include(r.b,e)),t.fragment.uniforms.add("size","vec2").add("color1","vec4").add("color2","vec4"),t.fragment.include(n.a),t.fragment.code.add(a.a`
    void main() {
      ${e.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
      vec2 uvScaled = vUV / (2.0 * size);

      vec2 uv = fract(uvScaled - 0.25);
      vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);
      float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));
      float t = mix(abs(ab.x + ab.y), 0.5, fade);

      gl_FragColor = mix(color2, color1, t);
      ${e.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    }
  `),t}var c=Object.freeze({__proto__:null,build:h})}}]);
//# sourceMappingURL=90.46460c9d.chunk.js.map